# Chapter 4.2: 8086 Register Organization

## ğŸ“š Chapter Overview

The 8086 has a rich set of 16-bit registers organized into general purpose, segment, pointer/index, and flag registers. Understanding register organization is essential for 8086 programming.

---

## ğŸ¯ Learning Objectives

After completing this chapter, you will be able to:
- Describe all 8086 registers and their purposes
- Explain general purpose register usage
- Understand segment register functions
- Use pointer and index registers effectively
- Interpret all flags in the flag register

---

## 1. Register Overview

### 1.1 Complete Register Set

```
8086 REGISTER ORGANIZATION:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        8086 REGISTERS                           â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              GENERAL PURPOSE REGISTERS                   â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    15              8  7               0                  â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚   â”‚
â”‚   â”‚    â”‚      AH       â”‚      AL       â”‚  AX (Accumulator)  â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚      BH       â”‚      BL       â”‚  BX (Base)         â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚      CH       â”‚      CL       â”‚  CX (Count)        â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚      DH       â”‚      DL       â”‚  DX (Data)         â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              SEGMENT REGISTERS                           â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    15                             0                      â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚   â”‚
â”‚   â”‚    â”‚              CS              â”‚  Code Segment        â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              DS              â”‚  Data Segment        â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              SS              â”‚  Stack Segment       â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              ES              â”‚  Extra Segment       â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚           POINTER AND INDEX REGISTERS                    â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    15                             0                      â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚   â”‚
â”‚   â”‚    â”‚              SP              â”‚  Stack Pointer       â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              BP              â”‚  Base Pointer        â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              SI              â”‚  Source Index        â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚              DI              â”‚  Destination Index   â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                 SPECIAL REGISTERS                        â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    15                             0                      â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚   â”‚
â”‚   â”‚    â”‚              IP              â”‚  Instruction Pointer â”‚   â”‚
â”‚   â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚   â”‚
â”‚   â”‚    â”‚            FLAGS             â”‚  Flag Register       â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TOTAL: 14 registers, all 16-bit
```

---

## 2. General Purpose Registers

### 2.1 AX - Accumulator

```
AX REGISTER (Accumulator):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                8  7            0 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚       AH        â”‚      AL     â”‚   â”‚
â”‚  â”‚   (High byte)   â”‚  (Low byte) â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚            AX (16-bit)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PRIMARY USES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Arithmetic Operations:
   â€¢ Implicit operand for MUL, DIV, IMUL, IDIV
   â€¢ Result destination for these operations

2. I/O Operations:
   â€¢ IN instruction: AL â† port (8-bit), AX â† port (16-bit)
   â€¢ OUT instruction: port â† AL, port â† AX

3. String Operations:
   â€¢ LODSB/LODSW: AL/AX â† [SI]
   â€¢ STOSB/STOSW: [DI] â† AL/AX

4. Decimal Adjust:
   â€¢ DAA, DAS, AAA, AAS, AAM, AAD use AL


EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Accessing as 16-bit
MOV AX, 1234H       ; AX = 1234H, AH = 12H, AL = 34H

; Accessing as 8-bit parts
MOV AH, 56H         ; AX = 5634H (AH changed, AL unchanged)
MOV AL, 78H         ; AX = 5678H (AL changed, AH unchanged)

; Multiplication (implicit AX)
MOV AL, 10H
MOV BL, 05H
MUL BL              ; AX = AL Ã— BL = 10H Ã— 05H = 50H

; I/O (implicit AX/AL)
IN AL, 60H          ; Read byte from port 60H into AL
OUT 61H, AL         ; Write AL to port 61H
```

### 2.2 BX - Base Register

```
BX REGISTER (Base):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                8  7            0 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚       BH        â”‚      BL     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚            BX (16-bit)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PRIMARY USES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Base Addressing:
   â€¢ Only general register usable for memory addressing
   â€¢ [BX] used for indirect addressing
   â€¢ Combined with SI/DI: [BX+SI], [BX+DI]

2. Table Lookup:
   â€¢ XLAT instruction: AL â† [BX+AL]
   â€¢ Translate table base address


EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Base addressing
MOV BX, 1000H       ; BX points to memory location
MOV AX, [BX]        ; AX = word at DS:1000H

; With displacement
MOV AL, [BX+5]      ; AL = byte at DS:BX+5

; With index register
MOV AX, [BX+SI]     ; AX = word at DS:BX+SI

; XLAT instruction
MOV BX, OFFSET TABLE    ; BX = table base
MOV AL, 5               ; Index = 5
XLAT                    ; AL = TABLE[5]
```

### 2.3 CX - Count Register

```
CX REGISTER (Count):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                8  7            0 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚       CH        â”‚      CL     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚            CX (16-bit)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PRIMARY USES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Loop Counter:
   â€¢ LOOP instruction uses CX
   â€¢ REP prefix for string operations

2. Shift/Rotate Count:
   â€¢ CL contains shift count
   â€¢ Variable shift operations

3. String Operations:
   â€¢ REP MOVSB, REP STOSW, etc.
   â€¢ CX = number of iterations


EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Loop counter
MOV CX, 10          ; Loop 10 times
LOOP_START:
    ; ... loop body ...
    LOOP LOOP_START ; CX--, jump if CX â‰  0

; Shift count
MOV CL, 4           ; Shift by 4 bits
SHL AX, CL          ; AX = AX << 4

; String operation count
MOV CX, 100         ; Copy 100 bytes
REP MOVSB           ; Move CX bytes from DS:SI to ES:DI
```

### 2.4 DX - Data Register

```
DX REGISTER (Data):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                8  7            0 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚       DH        â”‚      DL     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚            DX (16-bit)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PRIMARY USES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Multiplication (High Result):
   â€¢ 16Ã—16 multiplication: DX:AX = AX Ã— operand
   â€¢ DX contains high 16 bits

2. Division (Dividend Extension):
   â€¢ 32/16 division: DX:AX / operand = AX (quotient), DX (remainder)
   â€¢ DX:AX is 32-bit dividend

3. I/O Port Address:
   â€¢ IN AL, DX: Read from port in DX
   â€¢ OUT DX, AX: Write to port in DX
   â€¢ For ports > 255


EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; 16-bit multiplication
MOV AX, 1000H
MOV BX, 0100H
MUL BX              ; DX:AX = 1000H Ã— 100H = 00100000H
                    ; DX = 0010H, AX = 0000H

; 32-bit division
MOV DX, 0001H       ; DX:AX = 0001:0000H = 65536 decimal
MOV AX, 0000H
MOV BX, 0100H       ; Divisor = 256
DIV BX              ; AX = quotient = 256, DX = remainder = 0

; Variable I/O port
MOV DX, 3F8H        ; COM1 port
IN AL, DX           ; Read from port 3F8H
```

---

## 3. Segment Registers

### 3.1 Segment Register Functions

```
SEGMENT REGISTERS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   CS (Code Segment):                                            â”‚
â”‚   â€¢ Contains base of code segment                               â”‚
â”‚   â€¢ Points to area where instructions are stored                â”‚
â”‚   â€¢ Used with IP for instruction fetch: CS:IP                   â”‚
â”‚   â€¢ Cannot be directly loaded (use far JMP/CALL)               â”‚
â”‚                                                                  â”‚
â”‚   DS (Data Segment):                                            â”‚
â”‚   â€¢ Default segment for data access                             â”‚
â”‚   â€¢ Used with BX, SI, DI for addressing                         â”‚
â”‚   â€¢ MOV, ADD, SUB use DS by default                            â”‚
â”‚                                                                  â”‚
â”‚   SS (Stack Segment):                                           â”‚
â”‚   â€¢ Contains base of stack segment                              â”‚
â”‚   â€¢ Used with SP, BP for stack operations                       â”‚
â”‚   â€¢ PUSH, POP, CALL, RET use SS by default                     â”‚
â”‚                                                                  â”‚
â”‚   ES (Extra Segment):                                           â”‚
â”‚   â€¢ Extra data segment for string operations                    â”‚
â”‚   â€¢ Destination for MOVS, STOS, CMPS, SCAS                     â”‚
â”‚   â€¢ Can be used for additional data access                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SEGMENT USAGE IN INSTRUCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Memory Access    â”‚ Default Segmentâ”‚    Offset Register     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Instruction fetch  â”‚      CS        â”‚         IP             â”‚
â”‚ Stack operation    â”‚      SS        â”‚       SP or BP         â”‚
â”‚ Data access        â”‚      DS        â”‚    BX, SI, DI, disp    â”‚
â”‚ String destination â”‚      ES        â”‚         DI             â”‚
â”‚ String source      â”‚      DS        â”‚         SI             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Segment Override

```
SEGMENT OVERRIDE PREFIX:

Default segments can be overridden:

MOV AX, [BX]        ; DS:BX (default)
MOV AX, ES:[BX]     ; ES:BX (override)
MOV AX, CS:[BX]     ; CS:BX (override)
MOV AX, SS:[BX]     ; SS:BX (override)


SEGMENT OVERRIDE OPCODES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Segment   â”‚  Prefix  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    CS      â”‚   2EH    â”‚
â”‚    DS      â”‚   3EH    â”‚
â”‚    ES      â”‚   26H    â”‚
â”‚    SS      â”‚   36H    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
  MOV AX, ES:[BX]  â†’  26 8B 07
                      â†‘  â†‘  â†‘
                      â”‚  â”‚  â””â”€ ModR/M (AX, [BX])
                      â”‚  â””â”€â”€â”€â”€ Opcode (MOV r16, m16)
                      â””â”€â”€â”€â”€â”€â”€â”€ ES override prefix
```

---

## 4. Pointer and Index Registers

### 4.1 SP - Stack Pointer

```
SP (Stack Pointer):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                             0    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              SP               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FUNCTION:
â€¢ Points to top of stack (SS:SP)
â€¢ Decremented before PUSH
â€¢ Incremented after POP
â€¢ Used by CALL, RET, INT automatically


STACK OPERATIONS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PUSH AX:                      POP AX:
1. SP = SP - 2               1. AX = [SS:SP]
2. [SS:SP] = AX              2. SP = SP + 2

Before PUSH AX:    After PUSH AX:     After POP AX:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ...      â”‚    â”‚    ...      â”‚    â”‚    ...      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             â”‚    â”‚     AX      â”‚â—„SP â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â—„SP â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â—„SP
â”‚   Old TOS   â”‚    â”‚   Old TOS   â”‚    â”‚   Old TOS   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 BP - Base Pointer

```
BP (Base Pointer):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                             0    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              BP               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FUNCTION:
â€¢ Access stack data (parameters, local variables)
â€¢ Default segment is SS (not DS)
â€¢ Used in based addressing [BP], [BP+disp]
â€¢ Essential for subroutine parameter access


STACK FRAME ACCESS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Typical function prologue
PUSH BP             ; Save old BP
MOV BP, SP          ; BP = current stack top

; Stack frame layout:
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Parameter 2â”‚  [BP+6]
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚  Parameter 1â”‚  [BP+4]
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚  Return Addrâ”‚  [BP+2]
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  BP â”€â”€â–º â”‚   Old BP    â”‚  [BP+0]
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚  Local Var 1â”‚  [BP-2]
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  SP â”€â”€â–º â”‚  Local Var 2â”‚  [BP-4]
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

; Access parameters
MOV AX, [BP+4]      ; Get Parameter 1
MOV BX, [BP+6]      ; Get Parameter 2

; Access local variables
MOV [BP-2], CX      ; Store in Local Var 1
```

### 4.3 SI and DI - Index Registers

```
SI (Source Index) and DI (Destination Index):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                             0    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              SI               â”‚   â”‚ Default: DS
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              DI               â”‚   â”‚ Default: DS (or ES for strings)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PRIMARY USES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Index Addressing:
   MOV AX, [SI]         ; AX = DS:[SI]
   MOV AX, [DI]         ; AX = DS:[DI]
   MOV AX, [BX+SI]      ; AX = DS:[BX+SI]

2. String Operations:
   â€¢ SI: Source pointer (DS:SI)
   â€¢ DI: Destination pointer (ES:DI)
   â€¢ Auto-increment/decrement based on Direction Flag

3. Array Access:
   MOV SI, 0            ; Index = 0
   MOV AX, ARRAY[SI]    ; AX = ARRAY[0]
   ADD SI, 2            ; Next element
   MOV AX, ARRAY[SI]    ; AX = ARRAY[1]


STRING OPERATION EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Copy 100 bytes from SOURCE to DEST
CLD                 ; Clear Direction Flag (forward)
MOV SI, OFFSET SOURCE
MOV DI, OFFSET DEST
MOV CX, 100
REP MOVSB           ; [ES:DI] â† [DS:SI], SI++, DI++, CX--

; After each MOVSB:
; â€¢ Byte copied from DS:SI to ES:DI
; â€¢ SI and DI incremented by 1
; â€¢ CX decremented by 1
; â€¢ Repeats until CX = 0
```

---

## 5. Instruction Pointer (IP)

```
IP (Instruction Pointer):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15                             0    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              IP               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FUNCTION:
â€¢ Offset of next instruction within code segment
â€¢ Physical address = CS Ã— 16 + IP
â€¢ Cannot be directly accessed by programmer
â€¢ Modified by JMP, CALL, RET, INT, IRET


INSTRUCTION FETCH SEQUENCE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Calculate address: CS Ã— 16 + IP
2. Fetch instruction from that address
3. Decode instruction
4. Update IP to point to next instruction
5. Execute instruction

If IP = 0100H and CS = 2000H:
Physical address = 2000H Ã— 10H + 0100H = 20100H


IP MODIFICATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

JMP SHORT label    ; IP = IP + 8-bit displacement
JMP NEAR label     ; IP = 16-bit offset
JMP FAR label      ; CS:IP = new segment:offset
CALL procedure     ; Push IP, IP = procedure offset
RET                ; Pop IP from stack
LOOP label         ; If CX â‰  0: IP = IP + displacement
```

---

## 6. Flag Register

### 6.1 Flag Register Layout

```
8086 FLAG REGISTER (16-bit):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   15  14  13  12  11  10   9   8   7   6   5   4   3   2   1  0â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚  â”‚ - â”‚ - â”‚ - â”‚ - â”‚OF â”‚DF â”‚IF â”‚TF â”‚SF â”‚ZF â”‚ - â”‚AF â”‚ - â”‚PF â”‚ - â”‚CF â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â”‚       â”‚       â”‚
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â”‚       â”‚       â”‚
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â”‚       â”‚       â””â”€ Carry
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Parity
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Aux Carry
â”‚                   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zero
â”‚                   â”‚   â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Sign
â”‚                   â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trap
â”‚                   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Interrupt
â”‚                   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Direction
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Overflow
â”‚                                                                  â”‚
â”‚   STATUS FLAGS: CF, PF, AF, ZF, SF, OF (Set by ALU operations)  â”‚
â”‚   CONTROL FLAGS: TF, IF, DF (Set by special instructions)       â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 Status Flags

```
STATUS FLAGS (Set automatically by ALU):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   CF (Carry Flag) - Bit 0                                       â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Set if carry out from MSB (addition)                        â”‚
â”‚   â€¢ Set if borrow into MSB (subtraction)                        â”‚
â”‚   â€¢ Used for multi-precision arithmetic                         â”‚
â”‚   â€¢ Instructions: STC, CLC, CMC                                 â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   MOV AL, FFH     ; AL = 255                                    â”‚
â”‚   ADD AL, 01H     ; AL = 00H, CF = 1 (carry out)               â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   PF (Parity Flag) - Bit 2                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Set if result has even number of 1 bits (low byte)          â”‚
â”‚   â€¢ Used for error checking in communications                   â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   MOV AL, 07H     ; AL = 0000 0111 (three 1s = odd)            â”‚
â”‚   ; PF = 0 (odd parity)                                         â”‚
â”‚   MOV AL, 0FH     ; AL = 0000 1111 (four 1s = even)            â”‚
â”‚   ; PF = 1 (even parity)                                        â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   AF (Auxiliary Carry Flag) - Bit 4                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Set if carry from bit 3 to bit 4                            â”‚
â”‚   â€¢ Used for BCD arithmetic                                     â”‚
â”‚   â€¢ DAA, DAS instructions check AF                              â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   MOV AL, 0FH     ; AL = 0000 1111                              â”‚
â”‚   ADD AL, 01H     ; AL = 0001 0000, AF = 1 (carry from bit 3)  â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   ZF (Zero Flag) - Bit 6                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Set if result is zero                                       â”‚
â”‚   â€¢ Used for equality comparisons                               â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   SUB AX, AX      ; AX = 0, ZF = 1                              â”‚
â”‚   CMP AX, BX      ; If AX = BX, ZF = 1                          â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   SF (Sign Flag) - Bit 7                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Copy of MSB of result                                       â”‚
â”‚   â€¢ Indicates negative result in signed arithmetic              â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   MOV AL, 7FH     ; AL = +127                                   â”‚
â”‚   ADD AL, 02H     ; AL = 81H = -127, SF = 1                     â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   OF (Overflow Flag) - Bit 11                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Set if signed overflow occurred                             â”‚
â”‚   â€¢ Result too large/small for signed range                     â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   MOV AL, 7FH     ; AL = +127                                   â”‚
â”‚   ADD AL, 01H     ; AL = 80H = -128, OF = 1                     â”‚
â”‚   ; +127 + 1 = +128, but max signed is +127 â†’ overflow          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.3 Control Flags

```
CONTROL FLAGS (Set by specific instructions):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   TF (Trap Flag) - Bit 8                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ When set, CPU enters single-step mode                       â”‚
â”‚   â€¢ Generates INT 1 after each instruction                      â”‚
â”‚   â€¢ Used by debuggers                                           â”‚
â”‚                                                                  â”‚
â”‚   Setting TF:                                                    â”‚
â”‚   PUSHF               ; Push flags onto stack                   â”‚
â”‚   POP AX              ; Get flags in AX                         â”‚
â”‚   OR AX, 0100H        ; Set bit 8                               â”‚
â”‚   PUSH AX             ; Push modified flags                     â”‚
â”‚   POPF                ; Load flags with TF set                  â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   IF (Interrupt Enable Flag) - Bit 9                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Controls maskable interrupts (INTR)                         â”‚
â”‚   â€¢ IF = 1: Interrupts enabled                                  â”‚
â”‚   â€¢ IF = 0: Interrupts disabled                                 â”‚
â”‚   â€¢ Instructions: STI (set), CLI (clear)                        â”‚
â”‚   â€¢ NMI not affected by IF                                      â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   CLI                 ; Disable interrupts (IF = 0)             â”‚
â”‚   ; Critical section - no interrupts                            â”‚
â”‚   STI                 ; Enable interrupts (IF = 1)              â”‚
â”‚                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   DF (Direction Flag) - Bit 10                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚   â€¢ Controls string operation direction                         â”‚
â”‚   â€¢ DF = 0: Auto-increment SI, DI (forward)                     â”‚
â”‚   â€¢ DF = 1: Auto-decrement SI, DI (backward)                    â”‚
â”‚   â€¢ Instructions: CLD (clear), STD (set)                        â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚   CLD                 ; Clear DF, process forward               â”‚
â”‚   REP MOVSB           ; SI++, DI++ after each byte             â”‚
â”‚                                                                  â”‚
â”‚   STD                 ; Set DF, process backward                â”‚
â”‚   REP MOVSB           ; SI--, DI-- after each byte             â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.4 Flag Manipulation Instructions

```
FLAG MANIPULATION INSTRUCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Instruction   â”‚   Operation           â”‚   Flags Affected      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CLC           â”‚   Clear Carry         â”‚   CF = 0              â”‚
â”‚   STC           â”‚   Set Carry           â”‚   CF = 1              â”‚
â”‚   CMC           â”‚   Complement Carry    â”‚   CF = NOT CF         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CLD           â”‚   Clear Direction     â”‚   DF = 0              â”‚
â”‚   STD           â”‚   Set Direction       â”‚   DF = 1              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CLI           â”‚   Clear Interrupt     â”‚   IF = 0              â”‚
â”‚   STI           â”‚   Set Interrupt       â”‚   IF = 1              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   PUSHF         â”‚   Push Flags          â”‚   (none)              â”‚
â”‚   POPF          â”‚   Pop Flags           â”‚   All flags           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   LAHF          â”‚   Load AH from Flags  â”‚   (none)              â”‚
â”‚                 â”‚   AH = SF:ZF:0:AF:0:PF:1:CF                    â”‚
â”‚   SAHF          â”‚   Store AH to Flags   â”‚   SF,ZF,AF,PF,CF      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“‹ Summary Table

| Register | Size | Primary Purpose |
|----------|------|-----------------|
| AX | 16-bit | Accumulator, MUL/DIV, I/O |
| BX | 16-bit | Base addressing, XLAT |
| CX | 16-bit | Count for loops, shifts, strings |
| DX | 16-bit | Data extension, I/O port address |
| CS | 16-bit | Code segment base |
| DS | 16-bit | Data segment base |
| SS | 16-bit | Stack segment base |
| ES | 16-bit | Extra segment (string dest) |
| SP | 16-bit | Stack pointer |
| BP | 16-bit | Base pointer (stack frame) |
| SI | 16-bit | Source index |
| DI | 16-bit | Destination index |
| IP | 16-bit | Instruction pointer |
| FLAGS | 16-bit | Status and control flags |

---

## â“ Quick Revision Questions

1. **Which register is used as count for LOOP instruction?**
   <details>
   <summary>Show Answer</summary>
   CX register. LOOP decrements CX by 1 and jumps to the label if CX â‰  0. CX is also used for REP prefix count and CL for variable shift count.
   </details>

2. **What is the default segment for [BP] addressing?**
   <details>
   <summary>Show Answer</summary>
   SS (Stack Segment). Unlike [BX], [SI], [DI] which default to DS, the [BP] addressing mode defaults to SS because BP is primarily used to access stack frames.
   </details>

3. **Where is the multiplication result stored for 16-bit Ã— 16-bit?**
   <details>
   <summary>Show Answer</summary>
   DX:AX (32-bit result). The high 16 bits go to DX, low 16 bits to AX. For 8-bit Ã— 8-bit, result is in AX only.
   </details>

4. **What are the three control flags in 8086?**
   <details>
   <summary>Show Answer</summary>
   TF (Trap Flag) - single-step mode, IF (Interrupt Enable Flag) - enable/disable INTR, DF (Direction Flag) - string operation direction. Unlike status flags, these don't change based on ALU results.
   </details>

5. **How does CF differ from OF?**
   <details>
   <summary>Show Answer</summary>
   CF (Carry Flag) indicates unsigned overflow - carry/borrow beyond the data size. OF (Overflow Flag) indicates signed overflow - result outside signed range. For the same operation, CF and OF can have different values.
   </details>

6. **Which general purpose register can be used for indirect addressing?**
   <details>
   <summary>Show Answer</summary>
   BX is the only general purpose register that can be used for indirect memory addressing like [BX]. SI and DI are index registers, and BP is a pointer register - all can also be used, but AX, CX, DX cannot.
   </details>

---

## ğŸ§­ Navigation

| Previous | Up | Next |
|----------|-----|------|
| [4.1 Architecture and Pin Diagram](01-architecture-pin-diagram.md) | [Unit 4 Index](README.md) | [4.3 Memory Segmentation](03-memory-segmentation.md) |

---

*[â† Previous: Architecture and Pin Diagram](01-architecture-pin-diagram.md) | [Next: Memory Segmentation â†’](03-memory-segmentation.md)*
