# Chapter 9.5: ARM Architecture

## ğŸ“š Chapter Overview

This chapter covers ARM (Advanced RISC Machines) architecture, the dominant processor family in mobile devices, embedded systems, and increasingly in laptops and servers.

---

## ğŸ¯ Learning Objectives

After completing this chapter, you will be able to:
- Understand ARM's RISC design philosophy
- Explain ARM register organization and instruction set
- Describe ARM operating modes and exceptions
- Understand Thumb instruction encoding
- Compare ARM with x86 CISC architecture

---

## 1. ARM Architecture Overview

### 1.1 Introduction and History

```
ARM ARCHITECTURE HISTORY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

TIMELINE:
â”€â”€â”€â”€â”€â”€â”€â”€

1983: Acorn Computers starts ARM project
1985: ARM1 first silicon (26-bit address)
1987: ARM2 in Acorn Archimedes
1990: ARM Ltd spun off (ARM Holdings)
1991: ARM6 (first widely licensed)
1994: ARM7TDMI (Thumb, Debug, Multiplier, ICE)
1997: ARM9 (5-stage pipeline)
2002: ARM11 (8-stage pipeline)
2004: Cortex series begins
2011: 64-bit ARMv8 architecture
2020: Apple M1 (ARM-based Mac)

ARM BUSINESS MODEL:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ARM doesn't manufacture chips
â€¢ Licenses designs to chip makers
â€¢ Licensees: Apple, Qualcomm, Samsung, Nvidia, etc.
â€¢ Over 200 billion ARM chips shipped (most of any architecture)

ARM NAMING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Architecture    â”‚ Core Examples
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ARMv4T          â”‚ ARM7TDMI
ARMv5TE         â”‚ ARM9E, ARM10E
ARMv6           â”‚ ARM11
ARMv7-A         â”‚ Cortex-A8, A9, A15
ARMv7-R         â”‚ Cortex-R4, R5 (real-time)
ARMv7-M         â”‚ Cortex-M3, M4 (microcontroller)
ARMv8-A         â”‚ Cortex-A53, A72 (64-bit)
ARMv9           â”‚ Cortex-X2, A710 (latest)
```

### 1.2 RISC Design Philosophy

```
ARM RISC PRINCIPLES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   RISC (Reduced Instruction Set Computer) vs CISC:               â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚                                                             â”‚â”‚
â”‚   â”‚   RISC (ARM):                    CISC (x86):                â”‚â”‚
â”‚   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€â”€â”€                   â”‚â”‚
â”‚   â”‚   â€¢ Fixed instruction length     â€¢ Variable length          â”‚â”‚
â”‚   â”‚   â€¢ Load-store architecture      â€¢ Memory-to-memory ops     â”‚â”‚
â”‚   â”‚   â€¢ Large register file          â€¢ Few registers            â”‚â”‚
â”‚   â”‚   â€¢ Simple addressing modes      â€¢ Complex addressing       â”‚â”‚
â”‚   â”‚   â€¢ Hardware simplicity          â€¢ Complex microcode        â”‚â”‚
â”‚   â”‚   â€¢ Single-cycle execution       â€¢ Multi-cycle ops          â”‚â”‚
â”‚   â”‚   â€¢ Compiler does optimization   â€¢ Hardware does work       â”‚â”‚
â”‚   â”‚                                                             â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ARM SPECIFIC FEATURES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. CONDITIONAL EXECUTION
   - Most instructions can be conditionally executed
   - Reduces branches (good for pipeline)
   
2. BARREL SHIFTER
   - Shift/rotate operand in same instruction
   - ADD R0, R1, R2, LSL #3  ; R0 = R1 + (R2 << 3)

3. LOAD/STORE MULTIPLE
   - LDMIA, STMIA: Load/Store multiple registers
   - Efficient for function call/return

4. CONSTANT GENERATION
   - 8-bit constant with 4-bit rotation
   - Can create many constants without load
```

### 1.3 ARM Core Block Diagram

```
ARM7TDMI ARCHITECTURE (Classic ARM)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            ARM7TDMI Core                               â”‚
â”‚                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    Address Bus (32-bit)                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                   â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   â”‚                         â”‚                   â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ Instruction â”‚  â”‚  â”‚   REGISTER BANK   â”‚  â”‚  â”‚    Data     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   Decoder   â”‚  â”‚  â”‚                   â”‚  â”‚  â”‚   Buffer    â”‚ â”‚  â”‚
â”‚  â”‚  â”‚             â”‚  â”‚  â”‚  R0-R15 (32-bit)  â”‚  â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  ARM/Thumb  â”‚  â”‚  â”‚  + CPSR, SPSR     â”‚  â”‚  â”‚  32-bit     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚             â”‚  â”‚  â”‚                   â”‚  â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚         â”‚         â”‚            â”‚             â”‚         â”‚        â”‚  â”‚
â”‚  â”‚         â”‚         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚         â”‚        â”‚  â”‚
â”‚  â”‚         â”‚         â”‚  â”‚   BARREL SHIFTER  â”‚  â”‚         â”‚        â”‚  â”‚
â”‚  â”‚         â”‚         â”‚  â”‚   (32-bit shifts) â”‚  â”‚         â”‚        â”‚  â”‚
â”‚  â”‚         â”‚         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚         â”‚        â”‚  â”‚
â”‚  â”‚         â”‚         â”‚            â”‚             â”‚         â”‚        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚                   32-bit ALU                               â”‚â”‚  â”‚
â”‚  â”‚  â”‚                                                            â”‚â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ Arithmetic: ADD, SUB, RSB, ADC, SBC, RSC               â”‚â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ Logical: AND, ORR, EOR, BIC                            â”‚â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ Comparison: CMP, CMN, TST, TEQ                         â”‚â”‚  â”‚
â”‚  â”‚  â”‚                                                            â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â”‚                                   â”‚                             â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚                32 Ã— 32 MULTIPLIER                          â”‚â”‚  â”‚
â”‚  â”‚  â”‚                                                            â”‚â”‚  â”‚
â”‚  â”‚  â”‚  MUL, MLA (32-bit result)                                  â”‚â”‚  â”‚
â”‚  â”‚  â”‚  UMULL, SMULL (64-bit result)                              â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â”‚                                                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    Control Logic / Pipeline                      â”‚ â”‚
â”‚  â”‚                 3-stage: Fetch â†’ Decode â†’ Execute                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Register Organization

### 2.1 Register Set

```
ARM REGISTER SET (32-bit ARM state)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

GENERAL PURPOSE REGISTERS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

31                                                            0
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  R0  â”‚  General Purpose (also function argument/return)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R1  â”‚  General Purpose (function argument)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R2  â”‚  General Purpose (function argument)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R3  â”‚  General Purpose (function argument)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R4  â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R5  â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R6  â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R7  â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R8  â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R9  â”‚  General Purpose (platform specific)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R10 â”‚  General Purpose (callee saved)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R11 â”‚  FP - Frame Pointer (optional)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R12 â”‚  IP - Intra-Procedure scratch                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R13 â”‚  SP - Stack Pointer                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R14 â”‚  LR - Link Register (return address)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  R15 â”‚  PC - Program Counter                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SPECIAL REGISTERS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CPSR  â”‚  Current Program Status Register                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SPSR  â”‚  Saved Program Status Register (per mode)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

KEY DIFFERENCES FROM x86:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ 16 general purpose registers (vs 8 in x86)
â€¢ No dedicated accumulator - all registers equal
â€¢ PC is a general register (R15) - can read/write directly
â€¢ Link register (R14) instead of stack-based return
â€¢ All registers are 32-bit
```

### 2.2 Program Status Register (CPSR)

```
CURRENT PROGRAM STATUS REGISTER (CPSR)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Bit 31 30 29 28 27 26 25 24   ...  7  6  5  4  3  2  1  0
   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
   â”‚ N â”‚ Z â”‚ C â”‚ V â”‚ Q â”‚ I â”‚ J â”‚ . â”‚...â”‚ I â”‚ F â”‚ T â”‚ M â”‚ M â”‚ M â”‚ M â”‚
   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚ T â”‚   â”‚ . â”‚   â”‚   â”‚   â”‚   â”‚ 4 â”‚ 3 â”‚ 2-â”‚ 0 â”‚
   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
CONDITION FLAGS (bits 31-28):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
N (bit 31): Negative        - Set if result is negative
Z (bit 30): Zero            - Set if result is zero
C (bit 29): Carry           - Set if carry/borrow occurred
V (bit 28): Overflow        - Set if signed overflow occurred
Q (bit 27): Saturation      - Set if saturation occurred (DSP)

CONTROL BITS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
I (bit 7):  IRQ disable     - 1 = IRQ interrupts disabled
F (bit 6):  FIQ disable     - 1 = FIQ interrupts disabled
T (bit 5):  Thumb state     - 1 = Thumb mode, 0 = ARM mode

MODE BITS (bits 4-0):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
M[4:0] = 10000 (0x10): User mode
M[4:0] = 10001 (0x11): FIQ mode
M[4:0] = 10010 (0x12): IRQ mode
M[4:0] = 10011 (0x13): Supervisor mode
M[4:0] = 10111 (0x17): Abort mode
M[4:0] = 11011 (0x1B): Undefined mode
M[4:0] = 11111 (0x1F): System mode
```

### 2.3 Banked Registers

```
BANKED REGISTERS (Mode-specific copies)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ARM has separate register copies for different modes:

         User  System  FIQ    IRQ    SVC    Abort  Undef
        â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€   â”€â”€â”€â”€   â”€â”€â”€â”€   â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€
R0        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R1        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R2        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R3        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R4        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R5        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R6        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R7        â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
R8        â†â”€â”€â”€â”€ shared â”€â”€â”€â”€â†’  R8_fiq  â†â”€â”€ shared â”€â”€â”€â†’
R9        â†â”€â”€â”€â”€ shared â”€â”€â”€â”€â†’  R9_fiq  â†â”€â”€ shared â”€â”€â”€â†’
R10       â†â”€â”€â”€â”€ shared â”€â”€â”€â”€â†’  R10_fiq â†â”€â”€ shared â”€â”€â”€â†’
R11       â†â”€â”€â”€â”€ shared â”€â”€â”€â”€â†’  R11_fiq â†â”€â”€ shared â”€â”€â”€â†’
R12       â†â”€â”€â”€â”€ shared â”€â”€â”€â”€â†’  R12_fiq â†â”€â”€ shared â”€â”€â”€â†’
R13 (SP)  R13     R13     R13_fiq R13_irq R13_svc R13_abt R13_und
R14 (LR)  R14     R14     R14_fiq R14_irq R14_svc R14_abt R14_und
R15 (PC)  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
CPSR      â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
SPSR       -       -     SPSR_fiq SPSR_irq SPSR_svc SPSR_abt SPSR_und

BENEFITS:
â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Fast context switch on exceptions
â€¢ FIQ has most banked registers (R8-R14) for fast handlers
â€¢ Each mode has own SP for separate stacks
â€¢ SPSR saves CPSR on exception entry
```

---

## 3. Instruction Set

### 3.1 Instruction Format

```
ARM INSTRUCTION FORMAT (32-bit, Fixed Length)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

DATA PROCESSING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Bit 31  28 27 26 25 24    21 20 19  16 15  12 11              0
   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Cond â”‚ 00  â”‚ I â”‚ Opcode â”‚ S â”‚  Rn  â”‚  Rd  â”‚   Operand 2    â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cond:      Condition code (always, EQ, NE, CS, CC, etc.)
I:         0 = Operand2 is register, 1 = Operand2 is immediate
Opcode:    Operation (AND=0, EOR=1, SUB=2, ADD=4, etc.)
S:         Set condition flags
Rn:        First operand register
Rd:        Destination register
Operand2:  Second operand (register with shift, or immediate)

OPERAND2 FORMATS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Register with Shift:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bits 11-8: Shift amount (immediate) or Rs (shift register)      â”‚
â”‚ Bits 6-5:  Shift type (00=LSL, 01=LSR, 10=ASR, 11=ROR)          â”‚
â”‚ Bit 4:     0=Immediate shift, 1=Register shift                  â”‚
â”‚ Bits 3-0:  Rm (operand register)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Immediate:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bits 11-8: Rotate amount (multiply by 2)                         â”‚
â”‚ Bits 7-0:  8-bit immediate value                                 â”‚
â”‚                                                                  â”‚
â”‚ Immediate = value ROR (rotate Ã— 2)                               â”‚
â”‚ Example: value=0x12, rotate=4 â†’ 0x12 ROR 8 = 0x12000000         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Condition Codes

```
ARM CONDITIONAL EXECUTION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

CONDITION CODES (4-bit, bits 31-28):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Code  â”‚ Suffix â”‚ Meaning                  â”‚ Flags    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0000  â”‚  EQ    â”‚ Equal                    â”‚ Z=1      â”‚
â”‚ 0001  â”‚  NE    â”‚ Not Equal                â”‚ Z=0      â”‚
â”‚ 0010  â”‚  CS/HS â”‚ Carry Set/Higher Same    â”‚ C=1      â”‚
â”‚ 0011  â”‚  CC/LO â”‚ Carry Clear/Lower        â”‚ C=0      â”‚
â”‚ 0100  â”‚  MI    â”‚ Minus (Negative)         â”‚ N=1      â”‚
â”‚ 0101  â”‚  PL    â”‚ Plus (Positive or Zero)  â”‚ N=0      â”‚
â”‚ 0110  â”‚  VS    â”‚ Overflow Set             â”‚ V=1      â”‚
â”‚ 0111  â”‚  VC    â”‚ Overflow Clear           â”‚ V=0      â”‚
â”‚ 1000  â”‚  HI    â”‚ Higher (unsigned)        â”‚ C=1, Z=0 â”‚
â”‚ 1001  â”‚  LS    â”‚ Lower or Same (unsigned) â”‚ C=0 or Z=1â”‚
â”‚ 1010  â”‚  GE    â”‚ Greater or Equal (signed)â”‚ N=V      â”‚
â”‚ 1011  â”‚  LT    â”‚ Less Than (signed)       â”‚ Nâ‰ V      â”‚
â”‚ 1100  â”‚  GT    â”‚ Greater Than (signed)    â”‚ Z=0, N=V â”‚
â”‚ 1101  â”‚  LE    â”‚ Less or Equal (signed)   â”‚ Z=1 or Nâ‰ Vâ”‚
â”‚ 1110  â”‚  AL    â”‚ Always (default)         â”‚ -        â”‚
â”‚ 1111  â”‚  NV    â”‚ Never (deprecated)       â”‚ -        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE - Conditional vs Branch:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Traditional (with branch):          ARM Conditional:
    CMP R0, #0                      CMP R0, #0
    BEQ skip                        ADDNE R1, R1, R2
    ADD R1, R1, R2                  ; Only 2 instructions!
skip:                               ; No branch penalty
    ; 3 instructions + possible
    ; branch penalty

POWER OF CONDITIONAL EXECUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; if (a > b) max = a; else max = b;

; Without conditional:           With conditional:
    CMP R0, R1                   CMP R0, R1
    BGT else                     MOVGT R2, R0
    MOV R2, R1                   MOVLE R2, R1
    B done
else:
    MOV R2, R0
done:
    ; 5-6 instructions           ; 3 instructions, no branches!
```

### 3.3 Instruction Categories

```
ARM INSTRUCTION SET CATEGORIES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

DATA PROCESSING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Arithmetic:
    ADD Rd, Rn, Op2      ; Rd = Rn + Op2
    ADC Rd, Rn, Op2      ; Rd = Rn + Op2 + Carry
    SUB Rd, Rn, Op2      ; Rd = Rn - Op2
    SBC Rd, Rn, Op2      ; Rd = Rn - Op2 - !Carry
    RSB Rd, Rn, Op2      ; Rd = Op2 - Rn (Reverse Subtract)
    RSC Rd, Rn, Op2      ; Rd = Op2 - Rn - !Carry

Logical:
    AND Rd, Rn, Op2      ; Rd = Rn AND Op2
    ORR Rd, Rn, Op2      ; Rd = Rn OR Op2
    EOR Rd, Rn, Op2      ; Rd = Rn XOR Op2
    BIC Rd, Rn, Op2      ; Rd = Rn AND NOT Op2 (Bit Clear)

Move:
    MOV Rd, Op2          ; Rd = Op2
    MVN Rd, Op2          ; Rd = NOT Op2

Compare (set flags only):
    CMP Rn, Op2          ; Flags = Rn - Op2
    CMN Rn, Op2          ; Flags = Rn + Op2
    TST Rn, Op2          ; Flags = Rn AND Op2
    TEQ Rn, Op2          ; Flags = Rn XOR Op2

MULTIPLY:
â”€â”€â”€â”€â”€â”€â”€â”€

    MUL Rd, Rm, Rs       ; Rd = Rm Ã— Rs (32-bit result)
    MLA Rd, Rm, Rs, Rn   ; Rd = Rm Ã— Rs + Rn
    UMULL RdLo, RdHi, Rm, Rs  ; 64-bit unsigned
    SMULL RdLo, RdHi, Rm, Rs  ; 64-bit signed

LOAD/STORE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Single Register:
    LDR Rd, [Rn]         ; Load word
    LDRB Rd, [Rn]        ; Load byte
    LDRH Rd, [Rn]        ; Load halfword
    STR Rd, [Rn]         ; Store word
    STRB Rd, [Rn]        ; Store byte
    STRH Rd, [Rn]        ; Store halfword

Multiple Registers:
    LDMIA Rn!, {reglist} ; Load Multiple, Increment After
    STMIA Rn!, {reglist} ; Store Multiple, Increment After
    LDMDB Rn!, {reglist} ; Load Multiple, Decrement Before
    STMDB Rn!, {reglist} ; Store Multiple, Decrement Before
    PUSH {reglist}       ; = STMDB SP!, {reglist}
    POP {reglist}        ; = LDMIA SP!, {reglist}

BRANCH:
â”€â”€â”€â”€â”€â”€

    B label              ; Branch
    BL label             ; Branch with Link (call)
    BX Rm                ; Branch and Exchange (ARM/Thumb switch)
    BLX Rm               ; Branch Link and Exchange
```

---

## 4. Thumb Instruction Set

```
THUMB INSTRUCTION SET (16-bit Compressed)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PURPOSE:
â”€â”€â”€â”€â”€â”€â”€
â€¢ 16-bit instructions (half the size of ARM)
â€¢ Better code density (~65% of ARM size)
â€¢ Lower memory bandwidth
â€¢ Ideal for memory-constrained systems

TRADE-OFFS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ARM (32-bit):          Thumb (16-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ More powerful        â€¢ Simpler instructions
â€¢ Full register set    â€¢ Only R0-R7 directly
â€¢ All conditions       â€¢ Limited conditions
â€¢ Full shifter         â€¢ Limited shifts
â€¢ Better performance   â€¢ Better density

SWITCHING MODES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   ARM â†’ Thumb:      BX Rm (where Rm bit 0 = 1)                  â”‚
â”‚   Thumb â†’ ARM:      BX Rm (where Rm bit 0 = 0)                  â”‚
â”‚                                                                  â”‚
â”‚   CPSR.T bit: 0 = ARM state, 1 = Thumb state                    â”‚
â”‚                                                                  â”‚
â”‚   Example:                                                       â”‚
â”‚       LDR R0, =thumb_func + 1  ; Set bit 0 for Thumb            â”‚
â”‚       BX R0                    ; Switch to Thumb                 â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

THUMB INSTRUCTION FORMAT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Most Thumb instructions map to ARM instructions with restrictions:

Thumb:              ARM Equivalent:
â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ADD Rd, Rn, #imm3   ADD Rd, Rn, #imm (3-bit immediate)
ADD Rd, #imm8       ADD Rd, Rd, #imm (8-bit immediate)
MOV Rd, #imm8       MOV Rd, #imm (8-bit immediate)
LSL Rd, Rm, #imm5   MOV Rd, Rm, LSL #imm

THUMB-2 (Introduced in ARMv6T2):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â€¢ Mix of 16-bit and 32-bit instructions
â€¢ 32-bit Thumb instructions for complex ops
â€¢ Nearly same performance as ARM
â€¢ Best of both: density + capability
```

---

## 5. Operating Modes and Exceptions

### 5.1 Processor Modes

```
ARM PROCESSOR MODES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   PRIVILEGED MODES:                                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ FIQ Mode (Fast Interrupt)                                  â”‚â”‚
â”‚   â”‚ â€¢ Highest priority interrupt                               â”‚â”‚
â”‚   â”‚ â€¢ Most banked registers (R8-R14)                          â”‚â”‚
â”‚   â”‚ â€¢ For time-critical handlers                               â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ IRQ Mode (Normal Interrupt)                                â”‚â”‚
â”‚   â”‚ â€¢ Standard interrupt handling                              â”‚â”‚
â”‚   â”‚ â€¢ Banked R13, R14, SPSR                                   â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ Supervisor Mode (SVC)                                      â”‚â”‚
â”‚   â”‚ â€¢ Entered on reset and SVC instruction                     â”‚â”‚
â”‚   â”‚ â€¢ OS kernel runs here                                      â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ Abort Mode                                                 â”‚â”‚
â”‚   â”‚ â€¢ Memory access failures                                   â”‚â”‚
â”‚   â”‚ â€¢ Page faults, protection violations                       â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ Undefined Mode                                             â”‚â”‚
â”‚   â”‚ â€¢ Undefined instruction handling                           â”‚â”‚
â”‚   â”‚ â€¢ FPU emulation, coprocessor                               â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ System Mode                                                â”‚â”‚
â”‚   â”‚ â€¢ Privileged but uses User registers                       â”‚â”‚
â”‚   â”‚ â€¢ For OS tasks that need user register access              â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â”‚   UNPRIVILEGED MODE:                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚   â”‚ User Mode                                                  â”‚â”‚
â”‚   â”‚ â€¢ Application programs                                     â”‚â”‚
â”‚   â”‚ â€¢ Cannot change mode directly                              â”‚â”‚
â”‚   â”‚ â€¢ Limited access to system resources                       â”‚â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Exception Handling

```
ARM EXCEPTION VECTORS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

VECTOR TABLE (at address 0x00000000 or 0xFFFF0000):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Address  â”‚ Exception                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x00     â”‚ Reset                                       â”‚
â”‚ 0x04     â”‚ Undefined Instruction                       â”‚
â”‚ 0x08     â”‚ Software Interrupt (SVC/SWI)               â”‚
â”‚ 0x0C     â”‚ Prefetch Abort (instruction fetch failed)  â”‚
â”‚ 0x10     â”‚ Data Abort (data access failed)            â”‚
â”‚ 0x14     â”‚ Reserved (was Address exception)           â”‚
â”‚ 0x18     â”‚ IRQ (Interrupt Request)                    â”‚
â”‚ 0x1C     â”‚ FIQ (Fast Interrupt Request)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXCEPTION PRIORITY (highest first):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Reset
2. Data Abort
3. FIQ
4. IRQ
5. Prefetch Abort
6. SVC (Software Interrupt)
7. Undefined Instruction

EXCEPTION ENTRY SEQUENCE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Copy CPSR to SPSR_<mode>
2. Set appropriate CPSR bits:
   - Mode bits for exception mode
   - I bit (disable IRQ)
   - F bit (disable FIQ, for FIQ only)
   - T bit cleared (ARM state)
3. Store return address in LR_<mode>
4. Set PC to vector address

EXAMPLE VECTOR TABLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

vectors:
    LDR PC, reset_addr      ; 0x00: Reset
    LDR PC, undef_addr      ; 0x04: Undefined
    LDR PC, svc_addr        ; 0x08: SVC
    LDR PC, prefetch_addr   ; 0x0C: Prefetch Abort
    LDR PC, data_addr       ; 0x10: Data Abort
    NOP                     ; 0x14: Reserved
    LDR PC, irq_addr        ; 0x18: IRQ
    LDR PC, fiq_addr        ; 0x1C: FIQ

reset_addr:    .word reset_handler
undef_addr:    .word undef_handler
; ... etc
```

---

## 6. ARM Cortex Series

```
ARM CORTEX FAMILY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

CORTEX-A (Application):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ High performance
â€¢ Full OS support (Linux, Android)
â€¢ MMU for virtual memory
â€¢ Examples: A8, A9, A15, A53, A72, A76, X1

CORTEX-R (Real-time):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Deterministic timing
â€¢ MPU (Memory Protection Unit)
â€¢ Automotive, industrial
â€¢ Examples: R4, R5, R7, R8

CORTEX-M (Microcontroller):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Low power, low cost
â€¢ Simpler programming model
â€¢ Thumb-2 only (no ARM state)
â€¢ NVIC for interrupts
â€¢ Examples: M0, M0+, M3, M4, M7, M23, M33

COMPARISON TABLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature     â”‚ Cortex-A    â”‚ Cortex-R     â”‚ Cortex-M        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Target      â”‚ Applicationsâ”‚ Real-time    â”‚ Microcontroller â”‚
â”‚ Pipeline    â”‚ 8-13 stages â”‚ 8-11 stages  â”‚ 2-3 stages      â”‚
â”‚ Cache       â”‚ L1 + L2     â”‚ Optional     â”‚ Usually none    â”‚
â”‚ MMU/MPU     â”‚ MMU         â”‚ MPU          â”‚ Optional MPU    â”‚
â”‚ ISA         â”‚ ARM + Thumb â”‚ ARM + Thumb  â”‚ Thumb-2 only    â”‚
â”‚ Power       â”‚ Higher      â”‚ Medium       â”‚ Lowest          â”‚
â”‚ Use Cases   â”‚ Phones, IoT â”‚ Automotive   â”‚ Sensors, IoT    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“‹ ARM vs x86 Comparison

| Feature | ARM | x86 (Intel) |
|---------|-----|-------------|
| Architecture | RISC | CISC |
| Instruction Length | Fixed (32/16-bit) | Variable (1-15 bytes) |
| GP Registers | 16 (R0-R15) | 8/16 (EAX, etc.) |
| Load/Store | Separate instructions | Memory operands in ALU |
| Conditional | Most instructions | Only branches |
| Power Efficiency | Higher | Lower |
| Complexity | Simpler | More complex |
| Market | Mobile, Embedded | Desktop, Server |

---

## â“ Quick Revision Questions

1. **What is the purpose of the Link Register (R14)?**
   <details>
   <summary>Show Answer</summary>
   R14 (LR) stores the return address when BL (Branch with Link) is executed. On function call, LR = PC+4. To return, use MOV PC, LR or BX LR. This avoids stack push/pop for leaf functions. For nested calls, LR must be saved to stack.
   </details>

2. **Why does ARM use banked registers?**
   <details>
   <summary>Show Answer</summary>
   Banked registers provide automatic context saving on exception. Each mode has its own SP (R13) and LR (R14), plus SPSR to save CPSR. This enables fast exception entry without explicit save instructions. FIQ has most banked (R8-R14) for fastest response.
   </details>

3. **How does conditional execution reduce branches?**
   <details>
   <summary>Show Answer</summary>
   Most ARM instructions can include a condition code (EQ, NE, GT, etc.). The instruction only executes if condition is true, otherwise it's a NOP. Example: ADDNE R0, R1, R2 only adds if Z=0. This avoids branch instructions and their pipeline penalties.
   </details>

4. **What is the difference between ARM and Thumb mode?**
   <details>
   <summary>Show Answer</summary>
   ARM uses 32-bit instructions with full capability. Thumb uses 16-bit instructions with reduced capability (fewer registers directly accessible, limited immediate values). Thumb provides ~65% code density. Use BX to switch modes. CPSR.T bit indicates current mode.
   </details>

5. **What are the three Cortex families and their uses?**
   <details>
   <summary>Show Answer</summary>
   Cortex-A: Application processors for phones, tablets, full OS (Linux, Android). Cortex-R: Real-time processors for automotive, industrial with deterministic timing. Cortex-M: Microcontrollers for embedded, IoT, low power. Each optimized for its use case.
   </details>

6. **How does ARM's barrel shifter work?**
   <details>
   <summary>Show Answer</summary>
   Barrel shifter can shift/rotate the second operand in the same cycle as ALU operation. Example: ADD R0, R1, R2, LSL #3 computes R0 = R1 + (R2 << 3) in one instruction. Supports LSL, LSR, ASR, ROR. This reduces instruction count significantly.
   </details>

---

## ğŸ§­ Navigation

| Previous | Up | Next |
|----------|-----|------|
| [9.4 Pentium Architecture](04-pentium-architecture.md) | [Unit 9 Index](README.md) | [9.6 Processor Comparison](06-processor-comparison.md) |

---

*[â† Previous: Pentium Architecture](04-pentium-architecture.md) | [Next: Processor Comparison â†’](06-processor-comparison.md)*
