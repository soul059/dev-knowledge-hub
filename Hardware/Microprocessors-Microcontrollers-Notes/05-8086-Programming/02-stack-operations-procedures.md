# Chapter 5.2: Stack Operations and Procedures

## ğŸ“š Chapter Overview

This chapter covers stack mechanism in 8086, stack manipulation instructions, procedure definition and calling, and parameter passing techniques. Understanding these concepts is essential for modular programming.

---

## ğŸ¯ Learning Objectives

After completing this chapter, you will be able to:
- Understand stack memory organization
- Use PUSH and POP instructions effectively
- Create and call procedures
- Pass parameters to procedures
- Implement nested and recursive procedures

---

## 1. Stack Organization

### 1.1 Stack Concept

```
8086 STACK ORGANIZATION:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   â€¢ Stack = LIFO (Last In, First Out) memory structure         â”‚
â”‚   â€¢ Located in Stack Segment (SS)                              â”‚
â”‚   â€¢ Grows DOWNWARD (from high to low address)                  â”‚
â”‚   â€¢ SP (Stack Pointer) points to TOP of stack                  â”‚
â”‚   â€¢ BP (Base Pointer) used to access stack elements            â”‚
â”‚                                                                  â”‚
â”‚   STACK MEMORY LAYOUT:                                          â”‚
â”‚                                                                  â”‚
â”‚   High Address                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚            Stack Bottom                â”‚ â† Initial SP      â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚                                        â”‚                   â”‚
â”‚   â”‚           (Free Space)                 â”‚                   â”‚
â”‚   â”‚                                        â”‚                   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Data pushed earlier            â”‚                   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Data pushed later              â”‚                   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Most recent data               â”‚ â† Current SP      â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   (Stack Top)     â”‚
â”‚   â”‚                                        â”‚                   â”‚
â”‚   â”‚        (Unused - Below SP)             â”‚                   â”‚
â”‚   â”‚                                        â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚   Low Address                               â† Stack Limit       â”‚
â”‚                                                                  â”‚
â”‚   KEY POINTS:                                                    â”‚
â”‚   â€¢ PUSH decrements SP by 2, then stores word                  â”‚
â”‚   â€¢ POP reads word, then increments SP by 2                    â”‚
â”‚   â€¢ Stack operations are always word-sized (16-bit)            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Stack Pointer Behavior

```
PUSH AND POP OPERATIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   PUSH Operation (Example: PUSH AX where AX = 1234H):          â”‚
â”‚                                                                  â”‚
â”‚   BEFORE PUSH:           AFTER PUSH:                            â”‚
â”‚   SP = 0100H             SP = 00FEH                             â”‚
â”‚                                                                  â”‚
â”‚   Address   Data         Address   Data                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚   0100  â”Œâ”€â”€â”€â”€â”€â”€â”         0100  â”Œâ”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚         â”‚      â”‚               â”‚      â”‚                        â”‚
â”‚   00FF  â”‚      â”‚         00FF  â”‚  12  â”‚ â† High byte of AX      â”‚
â”‚         â”‚      â”‚               â”‚      â”‚                        â”‚
â”‚   00FE  â”‚      â”‚ â† SP    00FE  â”‚  34  â”‚ â† Low byte, SP points  â”‚
â”‚         â”‚      â”‚               â”‚      â”‚   here after PUSH      â”‚
â”‚   00FD  â””â”€â”€â”€â”€â”€â”€â”˜         00FD  â””â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                  â”‚
â”‚   Steps: 1. SP = SP - 2 (0100H â†’ 00FEH)                        â”‚
â”‚          2. Store AH at [SP+1] = 00FFH                         â”‚
â”‚          3. Store AL at [SP] = 00FEH                           â”‚
â”‚                                                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                                                  â”‚
â”‚   POP Operation (Example: POP BX):                              â”‚
â”‚                                                                  â”‚
â”‚   BEFORE POP:            AFTER POP:                             â”‚
â”‚   SP = 00FEH             SP = 0100H                             â”‚
â”‚                          BX = 1234H                             â”‚
â”‚                                                                  â”‚
â”‚   Address   Data         Address   Data                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚   0100  â”Œâ”€â”€â”€â”€â”€â”€â”         0100  â”Œâ”€â”€â”€â”€â”€â”€â” â† SP after POP         â”‚
â”‚         â”‚      â”‚               â”‚      â”‚                        â”‚
â”‚   00FF  â”‚  12  â”‚         00FF  â”‚  12  â”‚ (data still there      â”‚
â”‚         â”‚      â”‚               â”‚      â”‚  but inaccessible)     â”‚
â”‚   00FE  â”‚  34  â”‚ â† SP    00FE  â”‚  34  â”‚                        â”‚
â”‚         â”‚      â”‚               â”‚      â”‚                        â”‚
â”‚   00FD  â””â”€â”€â”€â”€â”€â”€â”˜         00FD  â””â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                  â”‚
â”‚   Steps: 1. Read word at [SP] into register                    â”‚
â”‚          2. SP = SP + 2 (00FEH â†’ 0100H)                        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Stack Instructions

### 2.1 PUSH Instruction

```
PUSH - Push onto Stack:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   SYNTAX:     PUSH source                                       â”‚
â”‚                                                                  â”‚
â”‚   OPERATION:  SP â† SP - 2                                       â”‚
â”‚               [SP+1:SP] â† source                                â”‚
â”‚                                                                  â”‚
â”‚   VALID SOURCES:                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   PUSH AX         ; Push 16-bit register               â”‚  â”‚
â”‚   â”‚   PUSH BX                                               â”‚  â”‚
â”‚   â”‚   PUSH CX                                               â”‚  â”‚
â”‚   â”‚   PUSH DX                                               â”‚  â”‚
â”‚   â”‚   PUSH SI                                               â”‚  â”‚
â”‚   â”‚   PUSH DI                                               â”‚  â”‚
â”‚   â”‚   PUSH BP                                               â”‚  â”‚
â”‚   â”‚   PUSH SP         ; Pushes value BEFORE decrement       â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   PUSH DS         ; Push segment registers              â”‚  â”‚
â”‚   â”‚   PUSH ES                                               â”‚  â”‚
â”‚   â”‚   PUSH SS                                               â”‚  â”‚
â”‚   â”‚   PUSH CS         ; Valid but rarely used              â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   PUSH [BX]       ; Push memory word                   â”‚  â”‚
â”‚   â”‚   PUSH WORD_VAR   ; Push variable                       â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; 8086 does NOT support:                              â”‚  â”‚
â”‚   â”‚   ; PUSH immediate value (added in 80186)              â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   FLAGS AFFECTED: None                                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 POP Instruction

```
POP - Pop from Stack:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   SYNTAX:     POP destination                                   â”‚
â”‚                                                                  â”‚
â”‚   OPERATION:  destination â† [SP+1:SP]                           â”‚
â”‚               SP â† SP + 2                                       â”‚
â”‚                                                                  â”‚
â”‚   VALID DESTINATIONS:                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   POP AX          ; Pop into 16-bit register           â”‚  â”‚
â”‚   â”‚   POP BX                                                â”‚  â”‚
â”‚   â”‚   POP CX                                                â”‚  â”‚
â”‚   â”‚   POP DX                                                â”‚  â”‚
â”‚   â”‚   POP SI                                                â”‚  â”‚
â”‚   â”‚   POP DI                                                â”‚  â”‚
â”‚   â”‚   POP BP                                                â”‚  â”‚
â”‚   â”‚   POP SP          ; Pop into SP (special case)         â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   POP DS          ; Pop into segment registers         â”‚  â”‚
â”‚   â”‚   POP ES                                                â”‚  â”‚
â”‚   â”‚   POP SS          ; Disables interrupts for next instr â”‚  â”‚
â”‚   â”‚   ; POP CS - NOT ALLOWED (would crash)                 â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   POP [BX]        ; Pop into memory                    â”‚  â”‚
â”‚   â”‚   POP WORD_VAR    ; Pop into variable                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   FLAGS AFFECTED: None                                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Other Stack Instructions

```
ADDITIONAL STACK OPERATIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   PUSHF - Push Flags:                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   PUSHF              ; Push FLAGS register onto stack   â”‚  â”‚
â”‚   â”‚                      ; SP = SP - 2                      â”‚  â”‚
â”‚   â”‚                      ; [SP] = FLAGS                     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   POPF - Pop Flags:                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   POPF               ; Pop top of stack into FLAGS      â”‚  â”‚
â”‚   â”‚                      ; FLAGS = [SP]                     â”‚  â”‚
â”‚   â”‚                      ; SP = SP + 2                      â”‚  â”‚
â”‚   â”‚   ; FLAGS AFFECTED: All flags modified                 â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   EXAMPLES:                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Save all registers                                  â”‚  â”‚
â”‚   â”‚   PUSH AX                                               â”‚  â”‚
â”‚   â”‚   PUSH BX                                               â”‚  â”‚
â”‚   â”‚   PUSH CX                                               â”‚  â”‚
â”‚   â”‚   PUSH DX                                               â”‚  â”‚
â”‚   â”‚   PUSHF                                                 â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; ... do some work ...                                â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Restore all registers (reverse order!)              â”‚  â”‚
â”‚   â”‚   POPF                                                  â”‚  â”‚
â”‚   â”‚   POP DX                                                â”‚  â”‚
â”‚   â”‚   POP CX                                                â”‚  â”‚
â”‚   â”‚   POP BX                                                â”‚  â”‚
â”‚   â”‚   POP AX                                                â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.4 Stack Usage Examples

```asm
; EXAMPLE 1: Swap two registers using stack
; Swap AX and BX without using third register

    PUSH AX         ; Stack: [AX]
    PUSH BX         ; Stack: [AX][BX] <- top
    POP AX          ; AX = old BX, Stack: [AX]
    POP BX          ; BX = old AX, Stack: empty

; EXAMPLE 2: Save and restore registers
SAVE_REGS PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    PUSH SI
    PUSH DI
    RET
SAVE_REGS ENDP

RESTORE_REGS PROC
    POP DI          ; LIFO - reverse order
    POP SI
    POP DX
    POP CX
    POP BX
    POP AX
    RET
RESTORE_REGS ENDP

; EXAMPLE 3: Exchange memory locations
; Exchange MEM1 and MEM2 (word variables)
    PUSH MEM1       ; Push first word
    PUSH MEM2       ; Push second word
    POP MEM1        ; MEM1 = old MEM2
    POP MEM2        ; MEM2 = old MEM1
```

---

## 3. Procedures

### 3.1 Procedure Definition

```
PROCEDURE STRUCTURE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   SYNTAX:                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   procedure_name PROC [NEAR/FAR]                        â”‚  â”‚
â”‚   â”‚       ; procedure body                                  â”‚  â”‚
â”‚   â”‚       RET                                               â”‚  â”‚
â”‚   â”‚   procedure_name ENDP                                   â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   NEAR PROCEDURE:                                               â”‚
â”‚   â€¢ Called from same code segment                               â”‚
â”‚   â€¢ RET pops 2 bytes (IP only)                                 â”‚
â”‚   â€¢ CALL pushes 2 bytes                                        â”‚
â”‚                                                                  â”‚
â”‚   FAR PROCEDURE:                                                â”‚
â”‚   â€¢ Called from different code segment                         â”‚
â”‚   â€¢ RET pops 4 bytes (CS and IP)                               â”‚
â”‚   â€¢ CALL pushes 4 bytes                                        â”‚
â”‚                                                                  â”‚
â”‚   EXAMPLE:                                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Near procedure (same segment)                       â”‚  â”‚
â”‚   â”‚   ADD_NUMS PROC NEAR                                    â”‚  â”‚
â”‚   â”‚       ADD AX, BX      ; Add BX to AX                   â”‚  â”‚
â”‚   â”‚       RET             ; Return to caller               â”‚  â”‚
â”‚   â”‚   ADD_NUMS ENDP                                        â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Far procedure (different segment)                   â”‚  â”‚
â”‚   â”‚   PRINT_MSG PROC FAR                                    â”‚  â”‚
â”‚   â”‚       MOV AH, 09H                                       â”‚  â”‚
â”‚   â”‚       INT 21H                                           â”‚  â”‚
â”‚   â”‚       RET             ; Far return (RETF)              â”‚  â”‚
â”‚   â”‚   PRINT_MSG ENDP                                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 CALL and RET Instructions

```
CALL AND RET MECHANISM:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   NEAR CALL:                                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   CALL procedure_name                                   â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Operation:                                            â”‚  â”‚
â”‚   â”‚   1. SP = SP - 2                                        â”‚  â”‚
â”‚   â”‚   2. Push IP (address of next instruction)              â”‚  â”‚
â”‚   â”‚   3. IP = address of procedure                          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   FAR CALL:                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   CALL FAR PTR procedure_name                           â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Operation:                                            â”‚  â”‚
â”‚   â”‚   1. SP = SP - 2, Push CS                               â”‚  â”‚
â”‚   â”‚   2. SP = SP - 2, Push IP                               â”‚  â”‚
â”‚   â”‚   3. CS:IP = address of procedure                       â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   NEAR RET:                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   RET                                                   â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Operation:                                            â”‚  â”‚
â”‚   â”‚   1. IP = [SP]                                          â”‚  â”‚
â”‚   â”‚   2. SP = SP + 2                                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   FAR RET:                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   RETF   or   RET (in FAR procedure)                    â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Operation:                                            â”‚  â”‚
â”‚   â”‚   1. IP = [SP], SP = SP + 2                             â”‚  â”‚
â”‚   â”‚   2. CS = [SP], SP = SP + 2                             â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   RET n (Return with stack cleanup):                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   RET 4              ; Pop return address, then SP+4    â”‚  â”‚
â”‚   â”‚                      ; Used to remove parameters        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 Stack Frame

```
STACK FRAME STRUCTURE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   When procedure is called with parameters:                     â”‚
â”‚                                                                  â”‚
â”‚   High Address                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚         Parameter N                    â”‚ [BP+6]            â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Parameter 2                    â”‚ [BP+4]            â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Parameter 1                    â”‚ [BP+2]            â”‚  
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Return Address (IP)            â”‚ â† Original SP     â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Old BP                         â”‚ â† BP points here  â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Local Variable 1               â”‚ [BP-2]            â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Local Variable 2               â”‚ [BP-4]            â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚   â”‚         Saved Registers                â”‚ â† Current SP      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚   Low Address                                                   â”‚
â”‚                                                                  â”‚
â”‚   STANDARD PROCEDURE ENTRY/EXIT:                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   PROC_NAME PROC                                        â”‚  â”‚
â”‚   â”‚       ; === ENTRY CODE (Prologue) ===                   â”‚  â”‚
â”‚   â”‚       PUSH BP             ; Save old base pointer       â”‚  â”‚
â”‚   â”‚       MOV BP, SP          ; Establish stack frame       â”‚  â”‚
â”‚   â”‚       SUB SP, 4           ; Allocate 4 bytes for locals â”‚  â”‚
â”‚   â”‚       PUSH BX             ; Save registers used         â”‚  â”‚
â”‚   â”‚       PUSH SI                                           â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚       ; === PROCEDURE BODY ===                          â”‚  â”‚
â”‚   â”‚       MOV AX, [BP+4]      ; Access parameter 1          â”‚  â”‚
â”‚   â”‚       MOV [BP-2], AX      ; Store in local variable     â”‚  â”‚
â”‚   â”‚       ; ... more code ...                               â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚       ; === EXIT CODE (Epilogue) ===                    â”‚  â”‚
â”‚   â”‚       POP SI              ; Restore registers           â”‚  â”‚
â”‚   â”‚       POP BX                                            â”‚  â”‚
â”‚   â”‚       MOV SP, BP          ; Deallocate locals           â”‚  â”‚
â”‚   â”‚       POP BP              ; Restore old BP              â”‚  â”‚
â”‚   â”‚       RET                 ; Return to caller            â”‚  â”‚
â”‚   â”‚   PROC_NAME ENDP                                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. Parameter Passing

### 4.1 Parameter Passing Methods

```
PARAMETER PASSING TECHNIQUES:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   1. VIA REGISTERS:                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Caller                          ; Procedure         â”‚  â”‚
â”‚   â”‚   MOV AX, 10        ; param 1       ADD_NUMS PROC       â”‚  â”‚
â”‚   â”‚   MOV BX, 20        ; param 2           ADD AX, BX      â”‚  â”‚
â”‚   â”‚   CALL ADD_NUMS                         RET             â”‚  â”‚
â”‚   â”‚   ; Result in AX                    ADD_NUMS ENDP       â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Advantages: Fast, simple                              â”‚  â”‚
â”‚   â”‚   Disadvantages: Limited by number of registers        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   2. VIA STACK:                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Caller (pushing right to left for C convention)    â”‚  â”‚
â”‚   â”‚   PUSH 20           ; param 2 (pushed first)           â”‚  â”‚
â”‚   â”‚   PUSH 10           ; param 1 (pushed last)            â”‚  â”‚
â”‚   â”‚   CALL ADD_NUMS                                         â”‚  â”‚
â”‚   â”‚   ADD SP, 4         ; Clean up stack (2 params Ã— 2)    â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Procedure                                           â”‚  â”‚
â”‚   â”‚   ADD_NUMS PROC                                         â”‚  â”‚
â”‚   â”‚       PUSH BP                                           â”‚  â”‚
â”‚   â”‚       MOV BP, SP                                        â”‚  â”‚
â”‚   â”‚       MOV AX, [BP+4]    ; param 1                       â”‚  â”‚
â”‚   â”‚       ADD AX, [BP+6]    ; param 2                       â”‚  â”‚
â”‚   â”‚       POP BP                                            â”‚  â”‚
â”‚   â”‚       RET                                               â”‚  â”‚
â”‚   â”‚   ADD_NUMS ENDP                                         â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Advantages: Unlimited parameters                     â”‚  â”‚
â”‚   â”‚   Disadvantages: Slower, more complex                  â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   3. VIA MEMORY (Global Variables):                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   .DATA                                                 â”‚  â”‚
â”‚   â”‚   PARAM1  DW  ?                                         â”‚  â”‚
â”‚   â”‚   PARAM2  DW  ?                                         â”‚  â”‚
â”‚   â”‚   RESULT  DW  ?                                         â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Caller                          ; Procedure         â”‚  â”‚
â”‚   â”‚   MOV PARAM1, 10                    ADD_NUMS PROC       â”‚  â”‚
â”‚   â”‚   MOV PARAM2, 20                        MOV AX, PARAM1  â”‚  â”‚
â”‚   â”‚   CALL ADD_NUMS                         ADD AX, PARAM2  â”‚  â”‚
â”‚   â”‚   ; Result in RESULT                    MOV RESULT, AX  â”‚  â”‚
â”‚   â”‚                                         RET             â”‚  â”‚
â”‚   â”‚                                     ADD_NUMS ENDP       â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   Disadvantages: Not reentrant, uses global memory     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Pass by Value vs Pass by Reference

```
VALUE vs REFERENCE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   PASS BY VALUE (copy of data):                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Caller                                              â”‚  â”‚
â”‚   â”‚   MOV AX, NUM1          ; Load value                   â”‚  â”‚
â”‚   â”‚   PUSH AX               ; Push copy                    â”‚  â”‚
â”‚   â”‚   CALL DOUBLE_IT                                        â”‚  â”‚
â”‚   â”‚   ; NUM1 is unchanged                                   â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Procedure                                           â”‚  â”‚
â”‚   â”‚   DOUBLE_IT PROC                                        â”‚  â”‚
â”‚   â”‚       PUSH BP                                           â”‚  â”‚
â”‚   â”‚       MOV BP, SP                                        â”‚  â”‚
â”‚   â”‚       MOV AX, [BP+4]    ; Get copy                     â”‚  â”‚
â”‚   â”‚       SHL AX, 1         ; Double it                    â”‚  â”‚
â”‚   â”‚       ; Original not modified                          â”‚  â”‚
â”‚   â”‚       POP BP                                            â”‚  â”‚
â”‚   â”‚       RET 2             ; Clean stack                  â”‚  â”‚
â”‚   â”‚   DOUBLE_IT ENDP                                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â”‚   PASS BY REFERENCE (address of data):                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   ; Caller                                              â”‚  â”‚
â”‚   â”‚   LEA BX, NUM1          ; Load address                 â”‚  â”‚
â”‚   â”‚   PUSH BX               ; Push address                 â”‚  â”‚
â”‚   â”‚   CALL DOUBLE_IT                                        â”‚  â”‚
â”‚   â”‚   ; NUM1 is now doubled!                               â”‚  â”‚
â”‚   â”‚                                                          â”‚  â”‚
â”‚   â”‚   ; Procedure                                           â”‚  â”‚
â”‚   â”‚   DOUBLE_IT PROC                                        â”‚  â”‚
â”‚   â”‚       PUSH BP                                           â”‚  â”‚
â”‚   â”‚       MOV BP, SP                                        â”‚  â”‚
â”‚   â”‚       MOV BX, [BP+4]    ; Get address                  â”‚  â”‚
â”‚   â”‚       MOV AX, [BX]      ; Get value via address        â”‚  â”‚
â”‚   â”‚       SHL AX, 1         ; Double it                    â”‚  â”‚
â”‚   â”‚       MOV [BX], AX      ; Store back - MODIFIES NUM1!  â”‚  â”‚
â”‚   â”‚       POP BP                                            â”‚  â”‚
â”‚   â”‚       RET 2                                             â”‚  â”‚
â”‚   â”‚   DOUBLE_IT ENDP                                        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Complete Procedure Examples

### 5.1 Procedure to Find Maximum

```asm
;------------------------------------------------
; PROCEDURE: Find maximum of two numbers
; INPUT:  AX = first number, BX = second number
; OUTPUT: AX = maximum value
;------------------------------------------------
FIND_MAX PROC NEAR
    CMP AX, BX          ; Compare AX with BX
    JGE MAX_DONE        ; If AX >= BX, AX already has max
    MOV AX, BX          ; Otherwise, max is in BX
MAX_DONE:
    RET
FIND_MAX ENDP

; USAGE:
;   MOV AX, 50
;   MOV BX, 75
;   CALL FIND_MAX       ; AX = 75
```

### 5.2 Procedure with Stack Parameters

```asm
;------------------------------------------------
; PROCEDURE: Add three numbers
; PARAMETERS: Three words on stack
; RETURNS: Sum in AX
;------------------------------------------------
ADD_THREE PROC NEAR
    PUSH BP
    MOV BP, SP
    
    MOV AX, [BP+4]      ; First parameter
    ADD AX, [BP+6]      ; Add second parameter
    ADD AX, [BP+8]      ; Add third parameter
    
    POP BP
    RET 6               ; Clean 6 bytes (3 words)
ADD_THREE ENDP

; USAGE:
;   PUSH 10             ; Third parameter
;   PUSH 20             ; Second parameter
;   PUSH 30             ; First parameter
;   CALL ADD_THREE      ; AX = 60
;   ; Stack automatically cleaned by RET 6
```

### 5.3 Recursive Procedure - Factorial

```asm
;------------------------------------------------
; PROCEDURE: Calculate factorial (recursive)
; INPUT:  AX = n (0-8 for 16-bit result)
; OUTPUT: AX = n!
;------------------------------------------------
FACTORIAL PROC NEAR
    CMP AX, 1           ; Base case: n <= 1
    JLE FACT_BASE
    
    PUSH AX             ; Save n
    DEC AX              ; n - 1
    CALL FACTORIAL      ; Recursive call: (n-1)!
    POP BX              ; Restore n into BX
    MUL BX              ; AX = n * (n-1)!
    RET

FACT_BASE:
    MOV AX, 1           ; 0! = 1, 1! = 1
    RET
FACTORIAL ENDP

; USAGE:
;   MOV AX, 5
;   CALL FACTORIAL      ; AX = 120 (5!)
```

### 5.4 Complete Program with Procedures

```asm
;------------------------------------------------
; PROGRAM: Calculate average of array
;------------------------------------------------
.MODEL SMALL
.STACK 100H

.DATA
    ARRAY   DW  10, 20, 30, 40, 50
    COUNT   DW  5
    SUM     DW  ?
    AVG     DW  ?
    MSG1    DB  'Sum = $'
    MSG2    DB  0DH, 0AH, 'Average = $'

.CODE
;------------------------------------------------
; PROCEDURE: Calculate sum of array
; INPUT:  SI = array address, CX = count
; OUTPUT: AX = sum
;------------------------------------------------
CALC_SUM PROC NEAR
    PUSH BX
    XOR AX, AX          ; AX = 0 (sum)
    
SUM_LOOP:
    ADD AX, [SI]        ; Add element
    ADD SI, 2           ; Next element
    LOOP SUM_LOOP       ; Decrement CX, repeat
    
    POP BX
    RET
CALC_SUM ENDP

;------------------------------------------------
; PROCEDURE: Display number
; INPUT: AX = number to display
;------------------------------------------------
DISP_NUM PROC NEAR
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV BX, 10          ; Divisor
    XOR CX, CX          ; Digit counter
    
CONV_LOOP:
    XOR DX, DX
    DIV BX              ; AX / 10, remainder in DX
    PUSH DX             ; Save digit
    INC CX
    OR AX, AX           ; Check if quotient = 0
    JNZ CONV_LOOP
    
PRINT_LOOP:
    POP DX
    ADD DL, '0'         ; Convert to ASCII
    MOV AH, 02H
    INT 21H
    LOOP PRINT_LOOP
    
    POP DX
    POP CX
    POP BX
    POP AX
    RET
DISP_NUM ENDP

;------------------------------------------------
; MAIN PROCEDURE
;------------------------------------------------
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    ; Calculate sum
    LEA SI, ARRAY
    MOV CX, COUNT
    CALL CALC_SUM
    MOV SUM, AX
    
    ; Calculate average
    XOR DX, DX
    DIV COUNT           ; AX = sum / count
    MOV AVG, AX
    
    ; Display sum
    MOV AH, 09H
    LEA DX, MSG1
    INT 21H
    MOV AX, SUM
    CALL DISP_NUM
    
    ; Display average
    MOV AH, 09H
    LEA DX, MSG2
    INT 21H
    MOV AX, AVG
    CALL DISP_NUM
    
    ; Exit
    MOV AH, 4CH
    INT 21H
MAIN ENDP

END MAIN
```

---

## ğŸ“‹ Summary Table

| Instruction | Operation | SP Change |
|-------------|-----------|-----------|
| PUSH reg16 | Push register | SP - 2 |
| PUSH mem16 | Push memory | SP - 2 |
| PUSH segreg | Push segment | SP - 2 |
| POP reg16 | Pop to register | SP + 2 |
| POP mem16 | Pop to memory | SP + 2 |
| POP segreg | Pop to segment | SP + 2 |
| PUSHF | Push flags | SP - 2 |
| POPF | Pop to flags | SP + 2 |
| CALL near | Push IP | SP - 2 |
| CALL far | Push CS, IP | SP - 4 |
| RET | Pop IP | SP + 2 |
| RET n | Pop IP, SP+n | SP + 2 + n |
| RETF | Pop IP, CS | SP + 4 |

---

## â“ Quick Revision Questions

1. **Why does the stack grow downward in 8086?**
   <details>
   <summary>Show Answer</summary>
   Historical design choice that allows stack and heap to grow toward each other from opposite ends of memory. Stack starts at high address and grows down (SP decrements), while heap/data starts at low address and grows up. This maximizes memory utilization.
   </details>

2. **What happens if you PUSH and POP in wrong order?**
   <details>
   <summary>Show Answer</summary>
   Stack corruption. Since stack is LIFO, if you PUSH AX then PUSH BX, you must POP BX first then POP AX. Wrong order puts wrong values in registers. If used for return addresses, wrong order causes program crash.
   </details>

3. **What is the difference between NEAR and FAR procedures?**
   <details>
   <summary>Show Answer</summary>
   NEAR procedures are in same code segment - CALL pushes only IP (2 bytes), RET pops only IP. FAR procedures can be in different segments - CALL pushes both CS and IP (4 bytes), RETF pops both. FAR calls are slower but allow cross-segment calls.
   </details>

4. **Why do we need `PUSH BP` and `MOV BP, SP` at procedure start?**
   <details>
   <summary>Show Answer</summary>
   This establishes a "stack frame". BP is saved because we'll modify it. Then BP is set to SP to create a fixed reference point. Since SP changes with PUSH/POP, using BP allows consistent access to parameters at [BP+4], [BP+6] etc. regardless of local variables pushed later.
   </details>

5. **What does `RET 4` do differently from `RET`?**
   <details>
   <summary>Show Answer</summary>
   RET pops return address and jumps back. RET 4 does the same but additionally adds 4 to SP, effectively removing 4 bytes (2 words) of parameters from stack. This is "callee cleans stack" convention, common in Pascal/stdcall calling convention.
   </details>

6. **How do you pass an array to a procedure?**
   <details>
   <summary>Show Answer</summary>
   Pass by reference: push the array's address (using LEA or OFFSET), and optionally push the count. Procedure uses the address to access elements. Example: `LEA SI, ARRAY` `PUSH SI` `PUSH COUNT` `CALL PROCESS_ARRAY`. Cannot pass entire array by value efficiently.
   </details>

---

## ğŸ§­ Navigation

| Previous | Up | Next |
|----------|-----|------|
| [5.1 Assembly Language Basics](01-assembly-language-basics.md) | [Unit 5 Index](README.md) | [5.3 Modular Programming](03-modular-programming.md) |

---

*[â† Previous: Assembly Language Basics](01-assembly-language-basics.md) | [Next: Modular Programming â†’](03-modular-programming.md)*
