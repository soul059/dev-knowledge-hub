# Chapter 2.3: Instruction Set Classification

## ğŸ“š Chapter Overview

The 8085 has a rich instruction set with 74 different instructions (246 opcodes including variations). This chapter classifies these instructions by function and format, providing the foundation for assembly language programming.

---

## ğŸ¯ Learning Objectives

After completing this chapter, you will be able to:
- Classify 8085 instructions by function
- Understand instruction formats and sizes
- Identify opcode encoding patterns
- Use appropriate instructions for different tasks

---

## 1. Instruction Classification Overview

### 1.1 Classification by Function

```
8085 INSTRUCTION CLASSIFICATION:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 8085 INSTRUCTION TYPES                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. DATA TRANSFER INSTRUCTIONS (28 types)                 â”‚  â”‚
â”‚  â”‚     â€¢ MOV, MVI, LDA, STA, LDAX, STAX                      â”‚  â”‚
â”‚  â”‚     â€¢ LXI, LHLD, SHLD, XCHG, XTHL, PUSH, POP             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  2. ARITHMETIC INSTRUCTIONS (14 types)                    â”‚  â”‚
â”‚  â”‚     â€¢ ADD, ADC, ADI, ACI                                  â”‚  â”‚
â”‚  â”‚     â€¢ SUB, SBB, SUI, SBI                                  â”‚  â”‚
â”‚  â”‚     â€¢ INR, DCR, INX, DCX, DAD, DAA                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  3. LOGICAL INSTRUCTIONS (14 types)                       â”‚  â”‚
â”‚  â”‚     â€¢ ANA, ANI, ORA, ORI, XRA, XRI                        â”‚  â”‚
â”‚  â”‚     â€¢ CMA, CMC, STC                                       â”‚  â”‚
â”‚  â”‚     â€¢ CMP, CPI                                            â”‚  â”‚
â”‚  â”‚     â€¢ RLC, RRC, RAL, RAR                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  4. BRANCH INSTRUCTIONS (20 types)                        â”‚  â”‚
â”‚  â”‚     â€¢ JMP, Jcondition (JZ, JNZ, JC, JNC, etc.)           â”‚  â”‚
â”‚  â”‚     â€¢ CALL, Ccondition                                    â”‚  â”‚
â”‚  â”‚     â€¢ RET, Rcondition                                     â”‚  â”‚
â”‚  â”‚     â€¢ RST 0-7, PCHL                                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  5. MACHINE CONTROL INSTRUCTIONS (6 types)                â”‚  â”‚
â”‚  â”‚     â€¢ NOP, HLT, DI, EI, SIM, RIM                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Classification by Instruction Size

```
INSTRUCTION SIZE CLASSIFICATION:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INSTRUCTION FORMATS                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  1-BYTE INSTRUCTIONS (46 types):                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                     â”‚
â”‚  â”‚ Opcode  â”‚                                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                     â”‚
â”‚  Examples: MOV A,B (78H), ADD B (80H), RET (C9H), NOP (00H)    â”‚
â”‚                                                                   â”‚
â”‚  2-BYTE INSTRUCTIONS (18 types):                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚  â”‚ Opcode  â”‚  Data/  â”‚                                          â”‚
â”‚  â”‚         â”‚  Port   â”‚                                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚  Examples: MVI A,data (3E,data), ADI data (C6,data)            â”‚
â”‚            IN port (DB,port), OUT port (D3,port)               â”‚
â”‚                                                                   â”‚
â”‚  3-BYTE INSTRUCTIONS (10 types):                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ Opcode  â”‚ Low Addrâ”‚High Addrâ”‚                                â”‚
â”‚  â”‚         â”‚  /Data  â”‚  /Data  â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚  Examples: LXI B,data16 (01,low,high)                          â”‚
â”‚            JMP addr (C3,low,high), LDA addr (3A,low,high)      â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Data Transfer Instructions

### 2.1 Register to Register Transfer

```
MOV INSTRUCTION:

Syntax: MOV D, S     (Move Source to Destination)
Opcode: 01 DDD SSS

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      MOV OPCODE ENCODING                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                       â”‚
â”‚   â”‚ D7 â”‚ D6 â”‚ D5 â”‚ D4 â”‚ D3 â”‚ D2 â”‚ D1 â”‚ D0 â”‚                       â”‚
â”‚   â”œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¤                       â”‚
â”‚   â”‚   01    â”‚     DDD      â”‚     SSS      â”‚                       â”‚
â”‚   â”‚  (MOV)  â”‚ (Dest code)  â”‚ (Src code)   â”‚                       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                                    â”‚
â”‚   Register Codes:                                                  â”‚
â”‚   B=000, C=001, D=010, E=011, H=100, L=101, M=110, A=111         â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MOV OPCODE TABLE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚   Toâ†’   â”‚  B   â”‚  C   â”‚  D   â”‚  E   â”‚  H   â”‚  L   â”‚  M   â”‚  A   â”‚
â”‚   Fromâ†“ â”‚ 000  â”‚ 001  â”‚ 010  â”‚ 011  â”‚ 100  â”‚ 101  â”‚ 110  â”‚ 111  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ B  000  â”‚ 40   â”‚ 41   â”‚ 42   â”‚ 43   â”‚ 44   â”‚ 45   â”‚ 46   â”‚ 47   â”‚
â”‚ C  001  â”‚ 48   â”‚ 49   â”‚ 4A   â”‚ 4B   â”‚ 4C   â”‚ 4D   â”‚ 4E   â”‚ 4F   â”‚
â”‚ D  010  â”‚ 50   â”‚ 51   â”‚ 52   â”‚ 53   â”‚ 54   â”‚ 55   â”‚ 56   â”‚ 57   â”‚
â”‚ E  011  â”‚ 58   â”‚ 59   â”‚ 5A   â”‚ 5B   â”‚ 5C   â”‚ 5D   â”‚ 5E   â”‚ 5F   â”‚
â”‚ H  100  â”‚ 60   â”‚ 61   â”‚ 62   â”‚ 63   â”‚ 64   â”‚ 65   â”‚ 66   â”‚ 67   â”‚
â”‚ L  101  â”‚ 68   â”‚ 69   â”‚ 6A   â”‚ 6B   â”‚ 6C   â”‚ 6D   â”‚ 6E   â”‚ 6F   â”‚
â”‚ M  110  â”‚ 70   â”‚ 71   â”‚ 72   â”‚ 73   â”‚ 74   â”‚ 75   â”‚ 76*  â”‚ 77   â”‚
â”‚ A  111  â”‚ 78   â”‚ 79   â”‚ 7A   â”‚ 7B   â”‚ 7C   â”‚ 7D   â”‚ 7E   â”‚ 7F   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
* 76H is HLT, not MOV M,M
```

### 2.2 Immediate Data Transfer

| Instruction | Opcode | Bytes | Operation | Example |
|-------------|--------|-------|-----------|---------|
| MVI r, data | 06/0E/16/1E/26/2E/3E | 2 | r â† data | MVI A, 45H |
| MVI M, data | 36 | 2 | M â† data | MVI M, 00H |
| LXI rp, data16 | 01/11/21/31 | 3 | rp â† data16 | LXI H, 2050H |

### 2.3 Memory Operations

```
MEMORY TRANSFER INSTRUCTIONS:

Direct Addressing:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LDA addr    Load A from memory         3A, low, high
STA addr    Store A to memory          32, low, high
LHLD addr   Load HL from memory        2A, low, high
SHLD addr   Store HL to memory         22, low, high

    Example: LDA 2050H
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Memory  â”‚
    â”‚  2050H  â”‚â”€â”€â”€â”€â”€â”€â–º Accumulator
    â”‚  [45H]  â”‚         [45H]
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Indirect Addressing:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LDAX B      A â† Memory[BC]             0A
LDAX D      A â† Memory[DE]             1A
STAX B      Memory[BC] â† A             02
STAX D      Memory[DE] â† A             12

    Example: LDAX D (DE = 3000H)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Memory  â”‚
    â”‚  3000H  â”‚â”€â”€â”€â”€â”€â”€â–º Accumulator
    â”‚  [7FH]  â”‚         [7FH]
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²
         â”‚
    DE = 3000H (pointer)


HL Indirect (M reference):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MOV A, M    A â† Memory[HL]             7E
MOV M, A    Memory[HL] â† A             77
MOV r, M    r â† Memory[HL]             46/4E/56/5E/66/6E
MOV M, r    Memory[HL] â† r             70-75, 77
```

### 2.4 Stack Operations

```
STACK INSTRUCTIONS:

PUSH rp     Push register pair to stack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before: SP=2400H, BC=1234H
    
    Stack Memory:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   23FE   â”‚         â”‚   23FE   â”‚ â† 34H
    â”‚   23FF   â”‚    â†’    â”‚   23FF   â”‚ â† 12H
    â”‚   2400   â”‚ â† SP    â”‚   2400   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–²
                         SP = 23FEH

    PUSH B: SP=SP-1, M[SP]=B, SP=SP-1, M[SP]=C

POP rp      Pop from stack to register pair
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before: SP=23FEH, Stack has [34H, 12H]
    
    POP D: E=M[SP], SP=SP+1, D=M[SP], SP=SP+1
    After: DE=1234H, SP=2400H

PUSH/POP Opcodes:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ Pair     â”‚ PUSH â”‚ POP  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ BC       â”‚  C5  â”‚  C1  â”‚
â”‚ DE       â”‚  D5  â”‚  D1  â”‚
â”‚ HL       â”‚  E5  â”‚  E1  â”‚
â”‚ PSW (AF) â”‚  F5  â”‚  F1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 Data Transfer Summary

| Instruction | Bytes | Cycles | Operation |
|-------------|-------|--------|-----------|
| MOV r1, r2 | 1 | 4 | r1 â† r2 |
| MOV r, M | 1 | 7 | r â† M[HL] |
| MOV M, r | 1 | 7 | M[HL] â† r |
| MVI r, data | 2 | 7 | r â† data |
| MVI M, data | 2 | 10 | M[HL] â† data |
| LXI rp, data16 | 3 | 10 | rp â† data16 |
| LDA addr | 3 | 13 | A â† M[addr] |
| STA addr | 3 | 13 | M[addr] â† A |
| LDAX rp | 1 | 7 | A â† M[rp] |
| STAX rp | 1 | 7 | M[rp] â† A |
| LHLD addr | 3 | 16 | HL â† M[addr] |
| SHLD addr | 3 | 16 | M[addr] â† HL |
| XCHG | 1 | 4 | HL â†” DE |
| PUSH rp | 1 | 12 | Stack â† rp |
| POP rp | 1 | 10 | rp â† Stack |

---

## 3. Arithmetic Instructions

### 3.1 Addition Operations

```
ADD INSTRUCTION FAMILY:

ADD r       A â† A + r           (80-87H based on register)
ADD M       A â† A + M[HL]       (86H)
ADI data    A â† A + data        (C6H, data)
ADC r       A â† A + r + CY      (88-8FH)
ADC M       A â† A + M[HL] + CY  (8EH)
ACI data    A â† A + data + CY   (CEH, data)

ADD OPCODE ENCODING:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   ADD r: 1000 0SSS (80H-87H)                                    â”‚
â”‚   ADC r: 1000 1SSS (88H-8FH)                                    â”‚
â”‚                                                                  â”‚
â”‚   Example: ADD B (80H) = 1000 0000                              â”‚
â”‚            ADD C (81H) = 1000 0001                              â”‚
â”‚            ADD A (87H) = 1000 0111  (A + A, doubles A)          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ADDITION EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    A = 3CH, B = 45H
    
    ADD B:
        0011 1100   (3CH)
      + 0100 0101   (45H)
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        1000 0001   (81H)
    
    Result: A = 81H
    Flags: S=1, Z=0, AC=0, P=1, CY=0

MULTI-BYTE ADDITION (16-bit example):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Add: 1234H + 5678H
    
    ; First number in BC = 1234H
    ; Second number in DE = 5678H
    ; Result in HL
    
    MOV A, C        ; A = 34H
    ADD E           ; A = 34H + 78H = ACH
    MOV L, A        ; L = ACH
    MOV A, B        ; A = 12H
    ADC D           ; A = 12H + 56H + CY = 68H
    MOV H, A        ; H = 68H
    ; Result: HL = 68ACH
```

### 3.2 Subtraction Operations

```
SUB INSTRUCTION FAMILY:

SUB r       A â† A - r           (90-97H)
SUB M       A â† A - M[HL]       (96H)
SUI data    A â† A - data        (D6H, data)
SBB r       A â† A - r - CY      (98-9FH)
SBB M       A â† A - M[HL] - CY  (9EH)
SBI data    A â† A - data - CY   (DEH, data)

SUB OPCODE ENCODING:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   SUB r: 1001 0SSS (90H-97H)                                    â”‚
â”‚   SBB r: 1001 1SSS (98H-9FH)                                    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SUBTRACTION EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    A = 45H, B = 3CH
    
    SUB B:
        0100 0101   (45H)
      - 0011 1100   (3CH)
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        0000 1001   (09H)
    
    Result: A = 09H
    Flags: S=0, Z=0, AC=1, P=1, CY=0

    If A < B (requires borrow):
    A = 3CH, B = 45H
    
    SUB B:
        0011 1100   (3CH)
      - 0100 0101   (45H)
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        1111 0111   (F7H) with borrow
    
    Result: A = F7H (2's complement of 09H)
    Flags: S=1, Z=0, CY=1 (borrow occurred)
```

### 3.3 Increment and Decrement

```
INCREMENT/DECREMENT INSTRUCTIONS:

INR r       r â† r + 1       (04/0C/14/1C/24/2C/3C)
INR M       M â† M + 1       (34)
DCR r       r â† r - 1       (05/0D/15/1D/25/2D/3D)
DCR M       M â† M - 1       (35)

INX rp      rp â† rp + 1     (03/13/23/33)
DCX rp      rp â† rp - 1     (0B/1B/2B/3B)

IMPORTANT:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚  INR/DCR: Affects S, Z, AC, P flags (NOT CY!)                  â”‚
â”‚  INX/DCX: Does NOT affect ANY flags!                            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE - Zero Flag with DCR:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MVI B, 03H      ; B = 03H
LOOP:
    DCR B           ; B = B - 1
    JNZ LOOP        ; Jump if Z = 0
    ; Loop executes 3 times
    ; When B becomes 0, Z=1, loop exits
```

### 3.4 Double Add (DAD)

```
DAD INSTRUCTION:

DAD rp      HL â† HL + rp    (Only affects CY flag!)

Opcodes:
    DAD B   (09H)   HL â† HL + BC
    DAD D   (19H)   HL â† HL + DE
    DAD H   (29H)   HL â† HL + HL  (Double HL)
    DAD SP  (39H)   HL â† HL + SP

EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    HL = 1234H, BC = 5678H
    
    DAD B:
        1234H
      + 5678H
      â”€â”€â”€â”€â”€â”€â”€
        68ACH
    
    Result: HL = 68ACH
    CY flag set if result > FFFFH
```

### 3.5 Decimal Adjust Accumulator

```
DAA INSTRUCTION:

DAA (Decimal Adjust Accumulator)
Used after ADD/ADC for BCD arithmetic

Algorithm:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. If lower nibble > 9 OR AC = 1:                               â”‚
â”‚    Add 06H to A                                                  â”‚
â”‚                                                                  â”‚
â”‚ 2. If upper nibble > 9 OR CY = 1:                               â”‚
â”‚    Add 60H to A                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE - BCD Addition:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Add BCD 29 + 48 = 77
    
    MVI A, 29H      ; A = 29H (BCD 29)
    ADI 48H         ; A = 29H + 48H = 71H
                    ; But 71H is valid BCD!
    
    Add BCD 49 + 38 = 87
    
    MVI A, 49H      ; A = 49H (BCD 49)
    ADI 38H         ; A = 49H + 38H = 81H (Invalid BCD!)
    DAA             ; Lower nibble: 1 < 9 (OK)
                    ; Upper nibble: 8 < 9 (OK)
                    ; Wait... AC was set during add!
                    ; A = 81H + 06H = 87H (Correct!)
```

---

## 4. Logical Instructions

### 4.1 AND, OR, XOR Operations

```
LOGICAL OPERATIONS:

ANA r       A â† A AND r     (A0-A7H)
ANA M       A â† A AND M     (A6H)
ANI data    A â† A AND data  (E6H)

ORA r       A â† A OR r      (B0-B7H)
ORA M       A â† A OR M      (B6H)
ORI data    A â† A OR data   (F6H)

XRA r       A â† A XOR r     (A8-AFH)
XRA M       A â† A XOR M     (AEH)
XRI data    A â† A XOR data  (EEH)

TRUTH TABLES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                    â”‚
â”‚   AND         OR          XOR                                     â”‚
â”‚   A B â”‚ Y    A B â”‚ Y     A B â”‚ Y                                 â”‚
â”‚   â”€â”€â”€â”€â”¼â”€â”€    â”€â”€â”€â”€â”¼â”€â”€     â”€â”€â”€â”€â”¼â”€â”€                                 â”‚
â”‚   0 0 â”‚ 0    0 0 â”‚ 0     0 0 â”‚ 0                                 â”‚
â”‚   0 1 â”‚ 0    0 1 â”‚ 1     0 1 â”‚ 1                                 â”‚
â”‚   1 0 â”‚ 0    1 0 â”‚ 1     1 0 â”‚ 1                                 â”‚
â”‚   1 1 â”‚ 1    1 1 â”‚ 1     1 1 â”‚ 0                                 â”‚
â”‚                                                                    â”‚
â”‚   Applications:                                                    â”‚
â”‚   AND - Masking bits, clearing bits                               â”‚
â”‚   OR  - Setting bits                                              â”‚
â”‚   XOR - Toggling bits, clearing register (XRA A â†’ A = 0)         â”‚
â”‚                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MASKING EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Extract lower 4 bits of A:
    
    A = 7BH = 0111 1011
    ANI 0FH = 0000 1111
              â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Result  = 0000 1011 = 0BH
    
    Set bit 7 of A:
    
    A = 3CH = 0011 1100
    ORI 80H = 1000 0000
              â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Result  = 1011 1100 = BCH

CLEAR ACCUMULATOR (Fast method):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    XRA A           ; A = A XOR A = 00H (1 byte, 4 cycles)
    vs
    MVI A, 00H      ; A = 00H (2 bytes, 7 cycles)
```

### 4.2 Complement and Carry Operations

```
COMPLEMENT INSTRUCTIONS:

CMA         A â† NOT A (1's complement)     (2FH)
CMC         CY â† NOT CY                    (3FH)
STC         CY â† 1                         (37H)

EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    A = 5AH = 0101 1010
    
    CMA:
    Result = 1010 0101 = A5H (1's complement)
    
    For 2's complement:
    CMA             ; A = A5H
    INR A           ; A = A6H (2's complement of 5AH)
```

### 4.3 Compare Instructions

```
COMPARE INSTRUCTIONS:

CMP r       A - r (result discarded, flags set)    (B8-BFH)
CMP M       A - M (result discarded, flags set)    (BEH)
CPI data    A - data (result discarded, flags set) (FEH)

FLAGS AFTER COMPARE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚   If A = operand:    Z = 1, CY = 0                              â”‚
â”‚   If A < operand:    Z = 0, CY = 1                              â”‚
â”‚   If A > operand:    Z = 0, CY = 0                              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MVI A, 45H
    MVI B, 30H
    CMP B           ; Compare A with B
    ; 45H > 30H, so Z=0, CY=0
    
    MVI A, 30H
    CPI 45H         ; Compare A with 45H
    ; 30H < 45H, so Z=0, CY=1
    
    MVI A, 45H
    CPI 45H         ; Compare A with 45H
    ; 45H = 45H, so Z=1, CY=0
```

### 4.4 Rotate Instructions

```
ROTATE INSTRUCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ROTATE OPERATIONS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  RLC (Rotate Left Circular):                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚  â”Œâ”€â”€â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                        â”‚
â”‚  â”‚  â”‚                                 â”‚ â”‚                        â”‚
â”‚  â”‚  â”‚   â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”           â”‚ â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â–ºâ”‚7â”‚6â”‚5â”‚4â”‚3â”‚2â”‚1â”‚0â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                        â”‚
â”‚  â”‚      â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜             â”‚                        â”‚
â”‚  â”‚               A                      â”‚                        â”‚
â”‚  â”‚      Also copied to CY              â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                   â”‚
â”‚  RRC (Rotate Right Circular):                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”€â”€â” â”‚                        â”‚
â”‚  â”‚  â”‚                                 â”‚ â”‚                        â”‚
â”‚  â”‚  â”‚   â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”           â”‚ â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”‚7â”‚6â”‚5â”‚4â”‚3â”‚2â”‚1â”‚0â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                        â”‚
â”‚  â”‚      â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜             â”‚                        â”‚
â”‚  â”‚               A                      â”‚                        â”‚
â”‚  â”‚      Also copied to CY              â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                   â”‚
â”‚  RAL (Rotate Left through Carry):                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚      â”Œâ”€â”€â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                        â”‚
â”‚  â”‚      â”‚                             â”‚ â”‚                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”   â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”       â”‚ â”‚                        â”‚
â”‚  â”‚  â”‚CY â”‚â—„â”€â”€â”‚7â”‚6â”‚5â”‚4â”‚3â”‚2â”‚1â”‚0â”‚â—„â”€â”€â”€â”€â”€â”€â”˜ â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”˜   â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜         â”‚                        â”‚
â”‚  â”‚                 A                    â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                   â”‚
â”‚  RAR (Rotate Right through Carry):                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”€â” â”‚                        â”‚
â”‚  â”‚  â”‚                                 â”‚ â”‚                        â”‚
â”‚  â”‚  â”‚   â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”   â”Œâ”€â”€â”€â”   â”‚ â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â–ºâ”‚7â”‚6â”‚5â”‚4â”‚3â”‚2â”‚1â”‚0â”‚â”€â”€â–ºâ”‚CY â”‚â”€â”€â”€â”˜ â”‚                        â”‚
â”‚  â”‚      â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜   â””â”€â”€â”€â”˜     â”‚                        â”‚
â”‚  â”‚               A                      â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    A = 85H = 1000 0101, CY = 0
    
    RLC:  A = 0000 1011 = 0BH, CY = 1 (bit 7 â†’ CY & bit 0)
    
    A = 85H, CY = 0
    RAL:  A = 0000 1010 = 0AH, CY = 1 (bit 7 â†’ CY, 0 â†’ bit 0)
    RAL:  A = 0001 0101 = 15H, CY = 0 (previous CY â†’ bit 0)
```

---

## 5. Branch Instructions

### 5.1 Unconditional Jumps

```
UNCONDITIONAL BRANCH:

JMP addr    PC â† addr           (C3H, low, high)
PCHL        PC â† HL             (E9H)

JMP OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Memory:
    2000: C3 00 30    ; JMP 3000H
    
    Execution:
    1. Fetch C3H, PC = 2001
    2. Fetch 00H (low), PC = 2002
    3. Fetch 30H (high), PC = 2003
    4. Load PC with 3000H
    5. Next instruction fetched from 3000H
```

### 5.2 Conditional Jumps

```
CONDITIONAL JUMP INSTRUCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Instruction  â”‚ Opcode â”‚       Condition             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     JZ        â”‚   CA   â”‚  Jump if Z = 1 (Zero)       â”‚
â”‚    JNZ        â”‚   C2   â”‚  Jump if Z = 0 (Not Zero)   â”‚
â”‚     JC        â”‚   DA   â”‚  Jump if CY = 1 (Carry)     â”‚
â”‚    JNC        â”‚   D2   â”‚  Jump if CY = 0 (No Carry)  â”‚
â”‚     JP        â”‚   F2   â”‚  Jump if S = 0 (Plus)       â”‚
â”‚     JM        â”‚   FA   â”‚  Jump if S = 1 (Minus)      â”‚
â”‚    JPE        â”‚   EA   â”‚  Jump if P = 1 (Even)       â”‚
â”‚    JPO        â”‚   E2   â”‚  Jump if P = 0 (Odd)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE - Counting Loop:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    MVI C, 05H      ; Counter = 5
LOOP:
    DCR C           ; C = C - 1
    JNZ LOOP        ; If C â‰  0, repeat
    HLT             ; Stop when C = 0
```

### 5.3 Call and Return

```
CALL AND RETURN INSTRUCTIONS:

CALL addr   Push PC, PC â† addr      (CDH)
RET         Pop PC                  (C9H)

CALL MECHANISM:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before CALL 3000H at address 2050H:
    PC = 2050H, SP = FFFFH
    
    1. Fetch CD, PC = 2051
    2. Fetch 00 (low), PC = 2052
    3. Fetch 30 (high), PC = 2053
    4. PUSH PC (2053H) to stack:
       SP = FFFE, Mem[FFFE] = 20H
       SP = FFFD, Mem[FFFD] = 53H
    5. PC â† 3000H
    
    After: PC = 3000H, SP = FFFDH
    
RET MECHANISM:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before RET: SP = FFFDH
    
    1. Fetch C9H
    2. POP PC:
       PC_low = Mem[FFFD] = 53H, SP = FFFE
       PC_high = Mem[FFFE] = 20H, SP = FFFF
    3. PC = 2053H
    
    Execution continues at 2053H


CONDITIONAL CALL/RETURN:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Call         â”‚ Opcode â”‚  Return       â”‚ Opcode â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    CZ         â”‚   CC   â”‚    RZ         â”‚   C8   â”‚
â”‚   CNZ         â”‚   C4   â”‚   RNZ         â”‚   C0   â”‚
â”‚    CC         â”‚   DC   â”‚    RC         â”‚   D8   â”‚
â”‚   CNC         â”‚   D4   â”‚   RNC         â”‚   D0   â”‚
â”‚    CP         â”‚   F4   â”‚    RP         â”‚   F0   â”‚
â”‚    CM         â”‚   FC   â”‚    RM         â”‚   F8   â”‚
â”‚   CPE         â”‚   EC   â”‚   RPE         â”‚   E8   â”‚
â”‚   CPO         â”‚   E4   â”‚   RPO         â”‚   E0   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 RST Instructions (Restart)

```
RST n (Restart) INSTRUCTIONS:

RST n   Push PC, PC â† n Ã— 8

â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RST  â”‚ Opcode â”‚ Vector Address â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ RST 0â”‚   C7   â”‚     0000H      â”‚
â”‚ RST 1â”‚   CF   â”‚     0008H      â”‚
â”‚ RST 2â”‚   D7   â”‚     0010H      â”‚
â”‚ RST 3â”‚   DF   â”‚     0018H      â”‚
â”‚ RST 4â”‚   E7   â”‚     0020H      â”‚
â”‚ RST 5â”‚   EF   â”‚     0028H      â”‚
â”‚ RST 6â”‚   F7   â”‚     0030H      â”‚
â”‚ RST 7â”‚   FF   â”‚     0038H      â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vector = n Ã— 8

RST is a 1-byte CALL instruction
Used for software interrupts and ISR vectors
```

---

## 6. Machine Control Instructions

```
MACHINE CONTROL INSTRUCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Inst   â”‚ Opcode â”‚ Bytes â”‚            Description               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   NOP   â”‚   00   â”‚   1   â”‚ No operation (4 T-states delay)      â”‚
â”‚   HLT   â”‚   76   â”‚   1   â”‚ Halt processor until interrupt       â”‚
â”‚   DI    â”‚   F3   â”‚   1   â”‚ Disable interrupts (IE = 0)          â”‚
â”‚   EI    â”‚   FB   â”‚   1   â”‚ Enable interrupts (IE = 1)           â”‚
â”‚   RIM   â”‚   20   â”‚   1   â”‚ Read interrupt mask and SID          â”‚
â”‚   SIM   â”‚   30   â”‚   1   â”‚ Set interrupt mask and SOD           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RIM/SIM FORMATS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RIM (Read Interrupt Mask) - After execution, A contains:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ SID â”‚I7.5 â”‚I6.5 â”‚I5.5 â”‚ IE  â”‚M7.5 â”‚M6.5 â”‚M5.5 â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
  D7    D6    D5    D4    D3    D2    D1    D0
  â”‚      â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
  â”‚      â”‚     â”‚     â”‚     â”‚     â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€ Mask bits (1=masked)
  â”‚      â”‚     â”‚     â”‚     â””â”€ Interrupt Enable (IE)
  â”‚      â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€ Pending interrupt flags
  â””â”€ Serial Input Data (SID pin level)


SIM (Set Interrupt Mask) - Load A before execution:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ SOD â”‚ SOE â”‚  X  â”‚R7.5 â”‚ MSE â”‚M7.5 â”‚M6.5 â”‚M5.5 â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
  D7    D6    D5    D4    D3    D2    D1    D0
  â”‚      â”‚           â”‚     â”‚     â”‚     â”‚     â”‚
  â”‚      â”‚           â”‚     â”‚     â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€ Mask bits (1=masked)
  â”‚      â”‚           â”‚     â””â”€ Mask Set Enable (must be 1)
  â”‚      â”‚           â””â”€ Reset RST 7.5 flip-flop
  â”‚      â””â”€ Serial Output Enable (must be 1 to change SOD)
  â””â”€ Serial Output Data (to SOD pin)
```

---

## ğŸ“‹ Summary Table

| Category | Instructions | Bytes | Example |
|----------|--------------|-------|---------|
| **Data Transfer** | MOV, MVI, LDA, STA, LXI, PUSH, POP | 1-3 | MOV A, B |
| **Arithmetic** | ADD, SUB, ADC, SBB, INR, DCR, DAD | 1-2 | ADD B |
| **Logical** | ANA, ORA, XRA, CMP, Rotate | 1-2 | ANI 0FH |
| **Branch** | JMP, J_cond_, CALL, RET, RST | 1-3 | JNZ LOOP |
| **Machine Control** | NOP, HLT, DI, EI, RIM, SIM | 1 | EI |

---

## â“ Quick Revision Questions

1. **How many types of instructions are in 8085? Name them.**
   <details>
   <summary>Show Answer</summary>
   Five types: (1) Data Transfer - 28 types, (2) Arithmetic - 14 types, (3) Logical - 14 types, (4) Branch - 20 types, (5) Machine Control - 6 types. Total: 74 instruction types.
   </details>

2. **What is the difference between ADD and ADC instructions?**
   <details>
   <summary>Show Answer</summary>
   ADD r: A â† A + r (adds register to accumulator). ADC r: A â† A + r + CY (adds register and carry flag to accumulator). ADC is used for multi-byte addition to propagate carry.
   </details>

3. **Which instructions do NOT affect the Carry flag?**
   <details>
   <summary>Show Answer</summary>
   INR, DCR (affect all flags except CY), INX, DCX (affect no flags), MOV, MVI, and most data transfer instructions do not affect carry.
   </details>

4. **Explain the difference between RLC and RAL.**
   <details>
   <summary>Show Answer</summary>
   RLC: Rotates A left, bit 7 goes to both bit 0 and CY. RAL: Rotates A left through carry, bit 7 goes to CY, previous CY goes to bit 0. RAL uses 9-bit rotation including CY.
   </details>

5. **What is the purpose of DAA instruction?**
   <details>
   <summary>Show Answer</summary>
   DAA (Decimal Adjust Accumulator) corrects the result in A after BCD addition. It adds 06H if lower nibble >9 or AC=1, and 60H if upper nibble >9 or CY=1, ensuring valid BCD result.
   </details>

6. **What is the difference between JMP, CALL, and RST instructions?**
   <details>
   <summary>Show Answer</summary>
   JMP: 3-byte, unconditional jump (PC â† addr). CALL: 3-byte, pushes return address to stack, then jumps (used for subroutines). RST: 1-byte CALL to fixed vector (nÃ—8), used for interrupts and short subroutine calls.
   </details>

---

## ğŸ§­ Navigation

| Previous | Up | Next |
|----------|-----|------|
| [2.2 Register Organization](02-register-organization.md) | [Unit 2 Index](README.md) | [2.4 Addressing Modes](04-addressing-modes.md) |

---

*[â† Previous: Register Organization](02-register-organization.md) | [Next: Addressing Modes â†’](04-addressing-modes.md)*
