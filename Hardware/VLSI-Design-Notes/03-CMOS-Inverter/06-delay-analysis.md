# Chapter 3.6: Delay Analysis

## ğŸ“‹ Chapter Overview

**Delay analysis** is fundamental to designing high-speed CMOS circuits. Understanding how to model, calculate, and optimize propagation delay allows designers to meet timing requirements. This chapter covers RC delay models, the Elmore delay approximation, and introduces the concept of logical effort for systematic delay optimization.

---

## ğŸ¯ Learning Objectives

After completing this chapter, you will be able to:
- Apply RC delay models to CMOS inverters
- Use Elmore delay for complex RC networks
- Understand intrinsic and extrinsic delay components
- Apply logical effort for delay optimization
- Size inverter chains for minimum delay

---

## 3.6.1 RC Delay Model

### Equivalent RC Circuit

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RC DELAY MODEL                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   CMOS Inverter                    RC Equivalent                    â”‚
â”‚                                                                      â”‚
â”‚       VDD                             VDD                            â”‚
â”‚        â”‚                               â”‚                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                        â”‚
â”‚   â”‚  PMOS   â”‚                     â”‚   R_p   â”‚                        â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                        â”‚
â”‚        â”‚                               â”‚                             â”‚
â”‚        â”œâ”€â”€â–º V_out                      â”œâ”€â”€â–º V_out                   â”‚
â”‚        â”‚                               â”‚                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                         â•â•â• C_L                       â”‚
â”‚   â”‚  NMOS   â”‚                          â”‚                             â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                        â”‚
â”‚        â”‚                          â”‚   R_n   â”‚                        â”‚
â”‚       GND                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                        â”‚
â”‚                                        â”‚                             â”‚
â”‚                                       GND                            â”‚
â”‚                                                                      â”‚
â”‚   During fall (NMOS ON):          During rise (PMOS ON):            â”‚
â”‚                                                                      â”‚
â”‚        R_n                             VDD                           â”‚
â”‚   â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€                          â”‚                             â”‚
â”‚        â”‚                          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                        â”‚
â”‚       â•â•â• C_L                     â”‚   R_p   â”‚                        â”‚
â”‚        â”‚                          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                        â”‚
â”‚       â”€â”´â”€                              â”‚                             â”‚
â”‚       GND                             â•â•â• C_L                        â”‚
â”‚                                        â”‚                             â”‚
â”‚   Ï„_n = R_n Ã— C_L                    â”€â”´â”€                            â”‚
â”‚                                       GND                            â”‚
â”‚                                   Ï„_p = R_p Ã— C_L                   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Delay Expressions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FIRST-ORDER DELAY EQUATIONS                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   RC time constant: Ï„ = R Ã— C                                       â”‚
â”‚                                                                      â”‚
â”‚   For exponential charging/discharging:                             â”‚
â”‚   V(t) = V_final + (V_initial - V_final)e^(-t/Ï„)                   â”‚
â”‚                                                                      â”‚
â”‚   50% point delay (propagation delay):                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   t_p = ln(2) Ã— Ï„ = 0.69 Ã— R Ã— C_L                          â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Individual delays:                                                â”‚
â”‚                                                                      â”‚
â”‚   t_pHL = 0.69 Ã— R_n Ã— C_L   (output falling)                      â”‚
â”‚                                                                      â”‚
â”‚   t_pLH = 0.69 Ã— R_p Ã— C_L   (output rising)                       â”‚
â”‚                                                                      â”‚
â”‚   Average propagation delay:                                        â”‚
â”‚                                                                      â”‚
â”‚   t_p = (t_pHL + t_pLH)/2 = 0.69 Ã— C_L Ã— (R_n + R_p)/2            â”‚
â”‚                                                                      â”‚
â”‚                                                                      â”‚
â”‚   Equivalent Resistance:                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚              VDD Ã— 0.5                    VDD                â”‚   â”‚
â”‚   â”‚   R_eq = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â‰ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”‚   â”‚
â”‚   â”‚          I_avg (0â†’VDD/2)    I_Dsat at VGS = VDD             â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Typical: R_eq ~ 10-20 kÎ©/â–¡ for minimum-size transistor   â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.6.2 Intrinsic and Extrinsic Delay

### Delay Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DELAY DECOMPOSITION                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   t_p = t_intrinsic + t_extrinsic                           â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚       = t_p0 + R_eq Ã— C_load                                â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚                                                                      â”‚
â”‚   INTRINSIC DELAY (t_p0):                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚   â€¢ Self-loading delay (driving its own capacitance)               â”‚
â”‚   â€¢ t_p0 = R_eq Ã— C_int (internal capacitance)                     â”‚
â”‚   â€¢ Fixed for a given transistor size                              â”‚
â”‚   â€¢ Represents minimum achievable delay                            â”‚
â”‚                                                                      â”‚
â”‚                                                                      â”‚
â”‚   EXTRINSIC DELAY (t_ext):                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚   â€¢ Load-dependent delay                                           â”‚
â”‚   â€¢ t_ext = R_eq Ã— C_ext                                           â”‚
â”‚   â€¢ C_ext = wire capacitance + gate cap of next stage             â”‚
â”‚   â€¢ Increases with fan-out                                         â”‚
â”‚                                                                      â”‚
â”‚                                                                      â”‚
â”‚   Graphically:                                                      â”‚
â”‚                                                                      â”‚
â”‚   t_p                                                               â”‚
â”‚      â”‚                                                              â”‚
â”‚      â”‚                              â•±                               â”‚
â”‚      â”‚                          â•±                                   â”‚
â”‚      â”‚                      â•±      Slope = R_eq                    â”‚
â”‚      â”‚                  â•±                                           â”‚
â”‚      â”‚              â•±                                               â”‚
â”‚   t_p0â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â—                                                   â”‚
â”‚      â”‚         â”‚                                                    â”‚
â”‚      â”‚         â”‚ Intrinsic                                         â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º C_load           â”‚
â”‚               C_int                                                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.6.3 Elmore Delay

### For Complex RC Networks

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ELMORE DELAY MODEL                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   For RC tree networks, Elmore delay gives first-order estimate:   â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   t_D = Î£ (C_i Ã— R_i-to-source)                             â”‚   â”‚
â”‚   â”‚         i                                                    â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Where R_i-to-source is the shared resistance from source  â”‚   â”‚
â”‚   â”‚   to capacitor C_i                                          â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Example: RC ladder                                                â”‚
â”‚                                                                      â”‚
â”‚   Source â”€â”€R1â”€â”€â”¬â”€â”€R2â”€â”€â”¬â”€â”€R3â”€â”€â”¬â”€â”€ Load                              â”‚
â”‚                â”‚      â”‚      â”‚                                      â”‚
â”‚               â•â•â•    â•â•â•    â•â•â•                                     â”‚
â”‚               C1     C2     C3                                      â”‚
â”‚                â”‚      â”‚      â”‚                                      â”‚
â”‚               GND    GND    GND                                     â”‚
â”‚                                                                      â”‚
â”‚   t_D = C1Ã—R1 + C2Ã—(R1+R2) + C3Ã—(R1+R2+R3)                        â”‚
â”‚                                                                      â”‚
â”‚                                                                      â”‚
â”‚   For uniform RC ladder (R,C each stage), n stages:                â”‚
â”‚                                                                      â”‚
â”‚   t_D = RCÃ—[1 + 2 + 3 + ... + n] = RC Ã— n(n+1)/2                  â”‚
â”‚                                                                      â”‚
â”‚   Quadratic with n â†’ distributed RC is slower than lumped          â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.6.4 Logical Effort

### Introduction to Logical Effort

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LOGICAL EFFORT CONCEPT                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   Logical Effort provides a systematic method to:                   â”‚
â”‚   â€¢ Compare gates by their intrinsic delay                         â”‚
â”‚   â€¢ Optimize multi-stage logic paths                               â”‚
â”‚   â€¢ Determine optimal number of stages and sizing                  â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Delay of a gate: d = g Ã— h + p                            â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Where:                                                     â”‚   â”‚
â”‚   â”‚   â€¢ g = Logical effort (gate complexity)                    â”‚   â”‚
â”‚   â”‚   â€¢ h = Electrical effort (C_out/C_in)                      â”‚   â”‚
â”‚   â”‚   â€¢ p = Parasitic delay (intrinsic delay)                   â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Units: delay normalized to inverter with h = 1            â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Logical Effort Definition:                                        â”‚
â”‚                                                                      â”‚
â”‚        Input capacitance of gate that provides same                â”‚
â”‚        output current as an inverter                                â”‚
â”‚   g = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚
â”‚        Input capacitance of that inverter                          â”‚
â”‚                                                                      â”‚
â”‚   Inverter has g = 1 (by definition)                               â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Logical Effort of Common Gates

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LOGICAL EFFORT VALUES                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚ Gate            â”‚ Logical Effortâ”‚ Parasitic    â”‚ Formula     â”‚ â”‚
â”‚   â”‚                 â”‚      (g)      â”‚ Delay (p)    â”‚             â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ Inverter        â”‚     1         â”‚     1        â”‚ d = h + 1   â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ 2-input NAND    â”‚     4/3       â”‚     2        â”‚ d=4h/3 + 2  â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ 3-input NAND    â”‚     5/3       â”‚     3        â”‚ d=5h/3 + 3  â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ n-input NAND    â”‚   (n+2)/3     â”‚     n        â”‚             â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ 2-input NOR     â”‚     5/3       â”‚     2        â”‚ d=5h/3 + 2  â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ 3-input NOR     â”‚     7/3       â”‚     3        â”‚ d=7h/3 + 3  â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ n-input NOR     â”‚   (2n+1)/3    â”‚     n        â”‚             â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ XOR, XNOR       â”‚     4         â”‚     4        â”‚             â”‚ â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚ Tristate inv    â”‚     2         â”‚     2        â”‚             â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                      â”‚
â”‚   Observation: NAND has lower g than NOR (NAND preferred)          â”‚
â”‚   More inputs â†’ Higher logical effort                               â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.6.5 Path Delay Optimization

### Multi-Stage Path

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MULTI-STAGE PATH DELAY                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   For N stages in series:                                           â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”                          â”‚
â”‚   â”‚ g1 â”‚â”€â”€â”€â”‚ g2 â”‚â”€â”€â”€â”‚ g3 â”‚â”€â”€â”€ ... â”€â”‚ gN â”‚â”€â”€â”€â–º C_L                  â”‚
â”‚   â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”˜                          â”‚
â”‚     h1       h2       h3             hN                             â”‚
â”‚                                                                      â”‚
â”‚   Total delay:                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   D = Î£ d_i = Î£ (g_i Ã— h_i + p_i)                           â”‚   â”‚
â”‚   â”‚       i       i                                              â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   D = Î£ g_iÃ—h_i + Î£ p_i = Î£ g_iÃ—h_i + P                     â”‚   â”‚
â”‚   â”‚       i           i       i                                  â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Path Electrical Effort:                                           â”‚
â”‚   H = C_L/C_in = h1 Ã— h2 Ã— h3 Ã— ... Ã— hN = Î  h_i                   â”‚
â”‚                                                                      â”‚
â”‚   Path Logical Effort:                                              â”‚
â”‚   G = g1 Ã— g2 Ã— g3 Ã— ... Ã— gN = Î  g_i                              â”‚
â”‚                                                                      â”‚
â”‚   Path Effort:                                                      â”‚
â”‚   F = G Ã— H                                                         â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Optimal Sizing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPTIMAL STAGE EFFORT                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   For minimum delay, stage efforts should be equal:                 â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Optimal stage effort: f = g_i Ã— h_i = F^(1/N)             â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   (equal for all stages)                                    â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Minimum delay: D_min = N Ã— F^(1/N) + P                    â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Optimal Number of Stages:                                         â”‚
â”‚                                                                      â”‚
â”‚   For inverter chain (g = 1, p = 1):                               â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   N_opt = ln(F) / ln(f_opt)                                 â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Where f_opt â‰ˆ 3.6 to 4 (optimal stage effort)            â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â”‚   Practical: f = 4 is often used (N_opt â‰ˆ ln(F)/ln(4))     â”‚   â”‚
â”‚   â”‚                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Stage effort vs delay trade-off:                                  â”‚
â”‚                                                                      â”‚
â”‚   D (normalized)                                                    â”‚
â”‚      â”‚                                                              â”‚
â”‚      â”‚  â—                        â—                                 â”‚
â”‚      â”‚   \                      /                                  â”‚
â”‚      â”‚    \                    /                                   â”‚
â”‚      â”‚     \                  /                                    â”‚
â”‚      â”‚      \                /                                     â”‚
â”‚      â”‚       \      â—â—â—â—â—â—â—â—â—                                      â”‚
â”‚      â”‚        â—â—â—â—â—â—â”‚                                              â”‚
â”‚      â”‚             â”‚â† f_opt â‰ˆ e â‰ˆ 2.7 (theory)                    â”‚
â”‚      â”‚             â”‚   â‰ˆ 4 (practical)                            â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º f                 â”‚
â”‚              1     4     16                                        â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.6.6 Inverter Chain Sizing Example

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INVERTER CHAIN DESIGN EXAMPLE                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   Problem: Design an inverter chain to drive C_L = 64Ã—C_in         â”‚
â”‚            with minimum delay                                       â”‚
â”‚                                                                      â”‚
â”‚   Given: F = C_L/C_in = 64, g = 1 (inverters), p = 1               â”‚
â”‚                                                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                      â”‚
â”‚   Step 1: Optimal number of stages                                  â”‚
â”‚                                                                      â”‚
â”‚   Using f_opt = 4:                                                  â”‚
â”‚   N = ln(64)/ln(4) = ln(64)/ln(4) = 3                              â”‚
â”‚                                                                      â”‚
â”‚   Check: 4Â³ = 64 âœ“                                                  â”‚
â”‚                                                                      â”‚
â”‚   Step 2: Stage effort                                              â”‚
â”‚                                                                      â”‚
â”‚   f = F^(1/N) = 64^(1/3) = 4                                       â”‚
â”‚                                                                      â”‚
â”‚   Step 3: Sizing                                                    â”‚
â”‚                                                                      â”‚
â”‚   Each stage has h = f/g = 4/1 = 4                                 â”‚
â”‚                                                                      â”‚
â”‚   Stage 1: C_in,1 = 1    â†’ drives 4Ã—                              â”‚
â”‚   Stage 2: C_in,2 = 4    â†’ drives 16Ã—                             â”‚
â”‚   Stage 3: C_in,3 = 16   â†’ drives 64Ã— (C_L)                       â”‚
â”‚                                                                      â”‚
â”‚      1Ã—        4Ã—        16Ã—                                        â”‚
â”‚     â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”                                        â”‚
â”‚   â”€â”€â”¤ 1 â”œâ”€â”€â”€â”€â”¤ 4 â”œâ”€â”€â”€â”€â”€â”¤16 â”œâ”€â”€â”€â”€â”¬â”€ C_L = 64                        â”‚
â”‚     â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜    â•                                   â”‚
â”‚                                GND                                   â”‚
â”‚                                                                      â”‚
â”‚   Step 4: Calculate delay                                           â”‚
â”‚                                                                      â”‚
â”‚   D = N Ã— f + P = 3 Ã— 4 + 3 Ã— 1 = 12 + 3 = 15 (normalized units)   â”‚
â”‚                                                                      â”‚
â”‚   Compare to single inverter:                                       â”‚
â”‚   D_single = g Ã— H + p = 1 Ã— 64 + 1 = 65 units                     â”‚
â”‚                                                                      â”‚
â”‚   Speedup: 65/15 = 4.3Ã— faster with 3-stage chain!                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Summary Table

| Concept | Key Formula | Notes |
|---------|-------------|-------|
| RC Delay | t_p = 0.69 Ã— R Ã— C | First-order model |
| Elmore Delay | t_D = Î£ C_i Ã— R_shared | For RC trees |
| Gate Delay | d = g Ã— h + p | Logical effort model |
| Optimal Stage Effort | f = F^(1/N) | Equal effort per stage |
| Optimal f | f_opt â‰ˆ 4 | Practical optimum |
| Optimal N | N = ln(F)/ln(4) | For inverter chains |
| Minimum Delay | D_min = N Ã— F^(1/N) + P | Best achievable |

### Logical Effort Quick Reference

| Gate | g | p |
|------|---|---|
| Inverter | 1 | 1 |
| 2-NAND | 4/3 | 2 |
| 3-NAND | 5/3 | 3 |
| 2-NOR | 5/3 | 2 |
| 3-NOR | 7/3 | 3 |

---

## â“ Quick Revision Questions

1. **Derive the propagation delay formula t_p = 0.69 Ã— R Ã— C from first principles.**

2. **What is the difference between intrinsic and extrinsic delay?**

3. **Calculate the Elmore delay for a 3-stage RC ladder with R=1kÎ©, C=10fF each.**

4. **Explain why logical effort of 2-NAND is 4/3 (greater than 1).**

5. **Design an inverter chain to drive C_L = 256Ã—C_in with minimum delay. Find N and stage sizes.**

6. **Why is f â‰ˆ 4 considered the practical optimal stage effort?**

---

## ğŸ”— Navigation

| Previous | Up | Next Unit |
|----------|-------|------|
| â† [Power Dissipation](05-power-dissipation.md) | [Unit 3 Home](README.md) | [Unit 4: Combinational Logic â†’](../04-Combinational-CMOS-Logic/README.md) |
