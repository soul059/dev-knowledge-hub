# Chapter 10.5: Circuit Design

[â† Previous: Logic Gates](04-logic-gates.md) | [Back to README](../README.md)

---

## ğŸ“‹ Chapter Overview

This final chapter brings together Boolean algebra, K-map minimization, and logic gates to design **combinational circuits** â€” circuits whose output depends only on current inputs. We cover the design methodology, then build important circuits: **half/full adders**, **subtractors**, **multiplexers**, **decoders**, and **encoders**, with ASCII circuit diagrams and timing diagrams throughout.

---

## 1. Combinational Circuit Design Methodology

```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚           Design Steps                               â”‚
  â”‚                                                      â”‚
  â”‚  1. Define the problem (inputs, outputs, behavior)   â”‚
  â”‚  2. Create the truth table                           â”‚
  â”‚  3. Write canonical SOP (or POS) from truth table    â”‚
  â”‚  4. Minimize using K-map or Boolean algebra          â”‚
  â”‚  5. Draw the gate-level circuit                      â”‚
  â”‚  6. Verify with truth table or simulation            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Half Adder

Adds **two 1-bit numbers**, producing a **Sum** and a **Carry**.

### Truth Table

```
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ A â”‚ B â”‚ Sum  â”‚ Carry â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0 â”‚ 0 â”‚  0   â”‚   0   â”‚
  â”‚ 0 â”‚ 1 â”‚  1   â”‚   0   â”‚
  â”‚ 1 â”‚ 0 â”‚  1   â”‚   0   â”‚
  â”‚ 1 â”‚ 1 â”‚  0   â”‚   1   â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Boolean Expressions

$$S = A \oplus B = \overline{A}B + A\overline{B}$$
$$C = A \cdot B$$

### Circuit Diagram

```
  A â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                  â”‚
          â”‚   â”Œâ”€â”€ NOT â”€â”€â”    â”‚
          â”œâ”€â”€â”€â”¤         â”œâ”€ ANDâ‚ â”€â”€â”
          â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â”‚
  B â”€â”€â”¬â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ OR â”€â”€â”€â”€ S (Sum)
      â”‚   â”‚                        â”‚
      â”‚   â”‚   â”Œâ”€â”€ NOT â”€â”€â”         â”‚
      â”‚   â””â”€â”€â”€â”¤         â”œâ”€ ANDâ‚‚ â”€â”€â”˜
      â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚            â†‘
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚
  A â”€â”€â”¤
      â”‚ ANDâ‚ƒ â”€â”€â”€â”€ C (Carry)
  B â”€â”€â”˜
  
  Simplified using XOR:
  
  A â”€â”€â”¬â”€â”€â”€â”€â”
      â”‚    â”‚ XOR â”œâ”€â”€â”€â”€ S = A âŠ• B
  B â”€â”€â”¼â”€â”€â”€â”€â”˜
      â”‚
  A â”€â”€â”¤
      â”‚ AND â”œâ”€â”€â”€â”€ C = A Â· B
  B â”€â”€â”˜
  
  Gate count: 1 XOR + 1 AND = 2 gates
```

### Block Diagram

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  A â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€ S (Sum)
          â”‚  Half      â”‚
  B â”€â”€â”€â”€â”€â”€â”¤  Adder     â”œâ”€â”€â”€â”€ C (Carry)
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Full Adder

Adds **two 1-bit numbers plus a carry-in**, producing Sum and Carry-out.

### Truth Table

```
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  â”‚ A â”‚ B â”‚ Cáµ¢â‚™ â”‚ Sum  â”‚ Câ‚’áµ¤â‚œ â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0 â”‚ 0 â”‚  0  â”‚  0   â”‚  0   â”‚
  â”‚ 0 â”‚ 0 â”‚  1  â”‚  1   â”‚  0   â”‚
  â”‚ 0 â”‚ 1 â”‚  0  â”‚  1   â”‚  0   â”‚
  â”‚ 0 â”‚ 1 â”‚  1  â”‚  0   â”‚  1   â”‚
  â”‚ 1 â”‚ 0 â”‚  0  â”‚  1   â”‚  0   â”‚
  â”‚ 1 â”‚ 0 â”‚  1  â”‚  0   â”‚  1   â”‚
  â”‚ 1 â”‚ 1 â”‚  0  â”‚  0   â”‚  1   â”‚
  â”‚ 1 â”‚ 1 â”‚  1  â”‚  1   â”‚  1   â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
```

### K-Map for Sum

```
              B Cáµ¢â‚™
           00    01    11    10
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  A=0   â”‚  0   â”‚  1   â”‚  0   â”‚  1   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  A=1   â”‚  1   â”‚  0   â”‚  1   â”‚  0   â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
  
  Checkerboard pattern â†’ cannot simplify
  S = A âŠ• B âŠ• Cáµ¢â‚™  (3-input XOR)
```

### K-Map for Carry-out

```
              B Cáµ¢â‚™
           00    01    11    10
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  A=0   â”‚  0   â”‚  0   â”‚  1   â”‚  0   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  A=1   â”‚  0   â”‚  1   â”‚  1   â”‚  1   â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
  
  Group 1: mâ‚ƒ, mâ‚‡ (B=1, Cáµ¢â‚™=1) â†’ BÂ·Cáµ¢â‚™
  Group 2: mâ‚…, mâ‚‡ (A=1, Cáµ¢â‚™=1) â†’ AÂ·Cáµ¢â‚™
  Group 3: mâ‚†, mâ‚‡ (A=1, B=1)   â†’ AÂ·B
  
  Câ‚’áµ¤â‚œ = AB + ACáµ¢â‚™ + BCáµ¢â‚™  (majority function!)
```

### Boolean Expressions

$$S = A \oplus B \oplus C_{in}$$
$$C_{out} = AB + AC_{in} + BC_{in} = AB + (A \oplus B)C_{in}$$

### Circuit (using two Half Adders)

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  A â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€ Sâ‚ â”€â”€â”¤            â”œâ”€â”€â”€â”€ S
          â”‚    HAâ‚     â”‚        â”‚    HAâ‚‚     â”‚
  B â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€ Câ‚   â”‚            â”œâ”€ Câ‚‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   Cáµ¢â‚™â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                           â”‚                     â”‚
                           â””â”€â”€â”€â”€ OR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€ Câ‚’áµ¤â‚œ
  
  Sâ‚ = A âŠ• B
  S  = Sâ‚ âŠ• Cáµ¢â‚™ = A âŠ• B âŠ• Cáµ¢â‚™ âœ“
  Câ‚ = A Â· B
  Câ‚‚ = Sâ‚ Â· Cáµ¢â‚™ = (A âŠ• B) Â· Cáµ¢â‚™
  Câ‚’áµ¤â‚œ = Câ‚ + Câ‚‚ = AB + (AâŠ•B)Cáµ¢â‚™ âœ“
```

### 4-Bit Ripple Carry Adder

```
  Aâ‚ƒBâ‚ƒ    Aâ‚‚Bâ‚‚    Aâ‚Bâ‚    Aâ‚€Bâ‚€
   â”‚ â”‚     â”‚ â”‚     â”‚ â”‚     â”‚ â”‚
   â–¼ â–¼     â–¼ â–¼     â–¼ â–¼     â–¼ â–¼
  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”
  â”‚FAâ‚ƒ â”‚â†â”€â”¤FAâ‚‚ â”‚â†â”€â”¤FAâ‚ â”‚â†â”€â”¤FAâ‚€ â”‚â†â”€â”€ Cáµ¢â‚™ = 0
  â””â”€â”€â”¬â”€â”˜  â””â”€â”€â”¬â”€â”˜  â””â”€â”€â”¬â”€â”˜  â””â”€â”€â”¬â”€â”˜
     â”‚        â”‚        â”‚        â”‚
  Câ‚’áµ¤â‚œ    Sâ‚ƒ      Sâ‚‚      Sâ‚      Sâ‚€
  
  Result: Câ‚’áµ¤â‚œ Sâ‚ƒ Sâ‚‚ Sâ‚ Sâ‚€  (5 bits)
  
  Carry ripples from FAâ‚€ â†’ FAâ‚ â†’ FAâ‚‚ â†’ FAâ‚ƒ
  Delay: 4 Ã— (carry propagation delay)
```

---

## 4. Half Subtractor

Computes $A - B$, producing **Difference** and **Borrow**.

```
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ A â”‚ B â”‚ Diff â”‚ Borrow â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0 â”‚ 0 â”‚  0   â”‚   0    â”‚
  â”‚ 0 â”‚ 1 â”‚  1   â”‚   1    â”‚  (0-1: borrow needed)
  â”‚ 1 â”‚ 0 â”‚  1   â”‚   0    â”‚
  â”‚ 1 â”‚ 1 â”‚  0   â”‚   0    â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  D = A âŠ• B       (same as half adder Sum!)
  Bâ‚’áµ¤â‚œ = Ä€ Â· B    (different from carry!)
  
  Circuit:
  A â”€â”€â”¬â”€â”€â”€â”€â”
      â”‚    â”‚ XOR â”œâ”€â”€â”€â”€ D = A âŠ• B
  B â”€â”€â”¼â”€â”€â”€â”€â”˜
      â”‚
  A â”€â”€ NOT â”€â”€â”
              â”‚ AND â”œâ”€â”€â”€â”€ Bâ‚’áµ¤â‚œ = Ä€ Â· B
  B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Multiplexer (MUX)

A **2â¿-to-1 multiplexer** selects one of $2^n$ data inputs based on $n$ select lines.

### 2-to-1 MUX

```
  Truth Table:
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  â”‚ S â”‚  Y   â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0 â”‚  Iâ‚€  â”‚
  â”‚ 1 â”‚  Iâ‚  â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
  
  Y = SÌ„Â·Iâ‚€ + SÂ·Iâ‚
  
  Circuit:
  
  Iâ‚€ â”€â”€â”€â”€â”€â”€â”
           â”‚ ANDâ‚ â”œâ”€â”€â”€â”€â”€â”€â”
  SÌ„ â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
                          â”‚ OR â”€â”€â”€â”€ Y
  Iâ‚ â”€â”€â”€â”€â”€â”€â”              â”‚
           â”‚ ANDâ‚‚ â”œâ”€â”€â”€â”€â”€â”€â”˜
  S â”€â”€â”€â”€â”€â”€â”€â”˜
  
  Block:
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  Iâ‚€ â”€â”€â”¤ 0       â”‚
       â”‚   MUX   â”œâ”€â”€â”€â”€ Y
  Iâ‚ â”€â”€â”¤ 1       â”‚
       â”‚         â”‚
  S  â”€â”€â”¤ sel     â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4-to-1 MUX

```
  Inputs: Iâ‚€, Iâ‚, Iâ‚‚, Iâ‚ƒ
  Select: Sâ‚, Sâ‚€
  
  Y = SÌ„â‚SÌ„â‚€Iâ‚€ + SÌ„â‚Sâ‚€Iâ‚ + Sâ‚SÌ„â‚€Iâ‚‚ + Sâ‚Sâ‚€Iâ‚ƒ
  
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  Iâ‚€ â”€â”€â”¤ 00       â”‚
  Iâ‚ â”€â”€â”¤ 01       â”‚
       â”‚   MUX    â”œâ”€â”€â”€â”€ Y
  Iâ‚‚ â”€â”€â”¤ 10       â”‚
  Iâ‚ƒ â”€â”€â”¤ 11       â”‚
       â”‚          â”‚
  Sâ‚ â”€â”€â”¤ Sâ‚  Sâ‚€  â”‚
  Sâ‚€ â”€â”€â”¤          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Sâ‚ â”‚ Sâ‚€ â”‚ Output  â”‚
  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  0 â”‚  0 â”‚   Iâ‚€    â”‚
  â”‚  0 â”‚  1 â”‚   Iâ‚    â”‚
  â”‚  1 â”‚  0 â”‚   Iâ‚‚    â”‚
  â”‚  1 â”‚  1 â”‚   Iâ‚ƒ    â”‚
  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementing Functions with MUX

Any $n$-variable function can be implemented with a $2^{n-1}$-to-1 MUX:

```
  Example: f(A,B,C) = Î£m(1,2,6,7) using 4-to-1 MUX
  
  Use A,B as select lines. Express f in terms of C:
  
  AB=00: f(0,0,C) = mâ‚ only â†’ f = C
  AB=01: f(0,1,C) = neither mâ‚‚(010) nor mâ‚ƒ â†’ wait
         mâ‚‚ = 010, so AB=01,C=0 â†’ f=1(mâ‚‚ is in list) 
         AB=01,C=1 â†’ mâ‚ƒ, not in list â†’ f=0
         So f = CÌ„
  AB=10: f(1,0,C): mâ‚„(100)=0, mâ‚…(101)=0 â†’ f = 0
  AB=11: f(1,1,C): mâ‚†(110)=1, mâ‚‡(111)=1 â†’ f = 1
  
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  C  â”€â”€â”¤ 00       â”‚
  CÌ„  â”€â”€â”¤ 01       â”‚
       â”‚   MUX    â”œâ”€â”€â”€â”€ f
  0  â”€â”€â”¤ 10       â”‚
  1  â”€â”€â”¤ 11       â”‚
       â”‚          â”‚
  A  â”€â”€â”¤ Sâ‚  Sâ‚€  â”‚
  B  â”€â”€â”¤          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. Decoder

An **$n$-to-$2^n$ decoder** activates exactly one of $2^n$ output lines based on the $n$-bit input code.

### 2-to-4 Decoder

```
  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
  â”‚ Aâ‚ â”‚ Aâ‚€ â”‚ Dâ‚€  â”‚ Dâ‚  â”‚ Dâ‚‚  â”‚ Dâ‚ƒ  â”‚
  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
  â”‚  0 â”‚  0 â”‚  1  â”‚  0  â”‚  0  â”‚  0  â”‚
  â”‚  0 â”‚  1 â”‚  0  â”‚  1  â”‚  0  â”‚  0  â”‚
  â”‚  1 â”‚  0 â”‚  0  â”‚  0  â”‚  1  â”‚  0  â”‚
  â”‚  1 â”‚  1 â”‚  0  â”‚  0  â”‚  0  â”‚  1  â”‚
  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
  
  Dâ‚€ = Ä€â‚ Â· Ä€â‚€     (minterm mâ‚€)
  Dâ‚ = Ä€â‚ Â· Aâ‚€     (minterm mâ‚)
  Dâ‚‚ = Aâ‚ Â· Ä€â‚€     (minterm mâ‚‚)
  Dâ‚ƒ = Aâ‚ Â· Aâ‚€     (minterm mâ‚ƒ)
  
  Circuit:
  
                   â”Œâ”€â”€ NOT â”€â”€â”
  Aâ‚ â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
       â”‚           â””â”€â”€ Ä€â‚ â”€â”€â”€â”¤
       â”‚                     â”‚
       â”‚   â”Œâ”€â”€ NOT â”€â”€â”       â”‚
  Aâ‚€ â”€â”€â”¼â”€â”€â”€â”¤         â”‚       â”‚
       â”‚   â””â”€â”€ Ä€â‚€ â”€â”€â”€â”¤       â”‚
       â”‚              â”‚       â”‚
       â”‚   Ä€â‚â”€â”€â”      â”‚       â”‚
       â”‚       â”‚ANDâ”œâ”€â”€ Dâ‚€ = Ä€â‚Ä€â‚€
       â”‚   Ä€â‚€â”€â”€â”˜      â”‚
       â”‚              â”‚
       â”‚   Ä€â‚â”€â”€â”      â”‚
       â”‚       â”‚ANDâ”œâ”€â”€ Dâ‚ = Ä€â‚Aâ‚€
       â”‚   Aâ‚€â”€â”€â”˜      
       â”‚              
       â”‚   Aâ‚â”€â”€â”      
       â”‚       â”‚ANDâ”œâ”€â”€ Dâ‚‚ = Aâ‚Ä€â‚€
       â”‚   Ä€â‚€â”€â”€â”˜      
       â”‚              
       â”‚   Aâ‚â”€â”€â”      
       â”‚       â”‚ANDâ”œâ”€â”€ Dâ‚ƒ = Aâ‚Aâ‚€
           Aâ‚€â”€â”€â”˜      
  
  Block:
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  Aâ‚ â”€â”€â”¤          â”œâ”€â”€â”€â”€ Dâ‚€
       â”‚  2-to-4  â”œâ”€â”€â”€â”€ Dâ‚
  Aâ‚€ â”€â”€â”¤  Decoder â”œâ”€â”€â”€â”€ Dâ‚‚
       â”‚          â”œâ”€â”€â”€â”€ Dâ‚ƒ
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementing Functions with Decoders

Since decoder outputs are **minterms**, any function is just an OR of the needed outputs:

```
  f(A,B) = Î£m(1,3) using 2-to-4 decoder:
  
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  A  â”€â”€â”¤          â”œâ”€â”€ Dâ‚€
       â”‚  2-to-4  â”œâ”€â”€ Dâ‚ â”€â”€â”
  B  â”€â”€â”¤  Decoder â”œâ”€â”€ Dâ‚‚   â”‚ OR â”€â”€â”€â”€ f
       â”‚          â”œâ”€â”€ Dâ‚ƒ â”€â”€â”˜
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  f = Dâ‚ + Dâ‚ƒ = Ä€Â·B + AÂ·B = B  âœ“
```

---

## 7. Encoder

### 4-to-2 Priority Encoder

When multiple inputs may be active, a **priority encoder** outputs the code for the **highest-priority** active input.

```
  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Dâ‚ƒ â”‚ Dâ‚‚ â”‚ Dâ‚ â”‚ Dâ‚€ â”‚  Aâ‚  â”‚  Aâ‚€  â”‚ Valid â”‚
  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  0 â”‚  0 â”‚  0 â”‚  0 â”‚  X   â”‚  X   â”‚   0   â”‚
  â”‚  0 â”‚  0 â”‚  0 â”‚  1 â”‚  0   â”‚  0   â”‚   1   â”‚
  â”‚  0 â”‚  0 â”‚  1 â”‚  X â”‚  0   â”‚  1   â”‚   1   â”‚
  â”‚  0 â”‚  1 â”‚  X â”‚  X â”‚  1   â”‚  0   â”‚   1   â”‚
  â”‚  1 â”‚  X â”‚  X â”‚  X â”‚  1   â”‚  1   â”‚   1   â”‚
  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
  
  Dâ‚ƒ has highest priority.
  
  Aâ‚ = Dâ‚ƒ + Dâ‚‚
  Aâ‚€ = Dâ‚ƒ + DÌ„â‚‚Â·Dâ‚
  V  = Dâ‚ƒ + Dâ‚‚ + Dâ‚ + Dâ‚€  (valid: any input active)
```

---

## 8. Timing Diagrams

Timing diagrams show how signals change over time â€” essential for understanding circuit behavior and propagation delays.

### AND Gate Timing

```
  Time â†’
        â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”
  A  â”€â”€â”€â”˜   â””â”€â”€â”€â”˜       â””â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€
  
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  B  â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€
  
          â”Œâ”€â”           â”Œâ”€â”€â”€â”
  AÂ·B â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  Output is HIGH only when BOTH inputs are HIGH.
```

### OR Gate Timing

```
  Time â†’
        â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”
  A  â”€â”€â”€â”˜   â””â”€â”€â”€â”˜       â””â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€
  
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  B  â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€
  
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  A+B â”˜         â””â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€
  
  Output is HIGH when EITHER input is HIGH.
```

### XOR Gate Timing

```
  Time â†’
        â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”
  A  â”€â”€â”€â”˜   â””â”€â”€â”€â”˜       â””â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€
  
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  B  â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€
  
      â”Œâ”€â” â”Œâ”€â”   â”Œâ”€â”€â”€â” â”Œâ”€â” â”Œâ”€â”
  AâŠ•B â”˜ â””â”€â”˜ â””â”€â”€â”€â”˜   â””â”€â”˜ â””â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  Output is HIGH when inputs DIFFER.
```

### Half Adder Timing

```
  Time â†’    tâ‚    tâ‚‚    tâ‚ƒ    tâ‚„
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  A     â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€
           â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜
  
  B     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                 â””â”€â”€â”€â”€â”€â”˜
  
           AB:  00    10    11    10
  
  S=AâŠ•B â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€
           â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜
  
  C=AÂ·B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€
                      â””â”€â”€â”€â”€â”€â”˜... 
  
  Wait, let me be more precise:
  
  tâ‚: A=0, B=0 â†’ S=0, C=0
  tâ‚‚: A=1, B=0 â†’ S=1, C=0
  tâ‚ƒ: A=1, B=1 â†’ S=0, C=1
  tâ‚„: A=0, B=1 â†’ S=1, C=0
  
  Time â†’  |  tâ‚  |  tâ‚‚  |  tâ‚ƒ  |  tâ‚„  |
          |      |      |      |      |
  A    â”€â”€â”€â”˜ LOW  â”Œâ”€â”€â”€â”€â”€â”€â” HIGH         â””â”€â”€ LOW
                 â””â”€â”€â”€â”€â”€â”€â”˜
  (A=0,0,1,1,0,0...)
  
  Better representation:
  
  Intervals:  | 00 | 01 | 10 | 11 |
  
  A  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€
  
  B  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  S  â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”
           â””â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€
  
  C  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â””â”€â”€â”  
                            â””â”€â”€â”€â”€â”€â”€â”€â”€
```

### Propagation Delay

```
  Real gates have propagation delay (tâ‚š):
  
  Time â†’
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Input â”€â”€â”€â”˜
  
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Output â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           |â†tâ‚šâ†’|
  
  Typical delays:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Gate   â”‚  Delay (ns)   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚   NOT    â”‚    1 - 3      â”‚
  â”‚   AND    â”‚    2 - 5      â”‚
  â”‚   OR     â”‚    2 - 5      â”‚
  â”‚   NAND   â”‚    1 - 3      â”‚
  â”‚   NOR    â”‚    1 - 3      â”‚
  â”‚   XOR    â”‚    3 - 8      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  NAND/NOR are faster than AND/OR
  (AND = NAND + NOT, so extra delay)
```

---

## 9. Complete Design Example

**Problem:** Design a circuit that detects if a 4-bit BCD input is **greater than 5** (i.e., outputs 6,7,8,9 detection).

### Step 1: Truth Table

```
  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  â”‚ A  â”‚ B  â”‚ C  â”‚ D  â”‚  f   â”‚
  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  â”‚  0 â”‚  0 â”‚  0 â”‚  0 â”‚  0   â”‚  0
  â”‚  0 â”‚  0 â”‚  0 â”‚  1 â”‚  0   â”‚  1
  â”‚  0 â”‚  0 â”‚  1 â”‚  0 â”‚  0   â”‚  2
  â”‚  0 â”‚  0 â”‚  1 â”‚  1 â”‚  0   â”‚  3
  â”‚  0 â”‚  1 â”‚  0 â”‚  0 â”‚  0   â”‚  4
  â”‚  0 â”‚  1 â”‚  0 â”‚  1 â”‚  0   â”‚  5
  â”‚  0 â”‚  1 â”‚  1 â”‚  0 â”‚  1   â”‚  6
  â”‚  0 â”‚  1 â”‚  1 â”‚  1 â”‚  1   â”‚  7
  â”‚  1 â”‚  0 â”‚  0 â”‚  0 â”‚  1   â”‚  8
  â”‚  1 â”‚  0 â”‚  0 â”‚  1 â”‚  1   â”‚  9
  â”‚  1 â”‚  0 â”‚  1 â”‚  0 â”‚  X   â”‚  10 (invalid BCD)
  â”‚  1 â”‚  0 â”‚  1 â”‚  1 â”‚  X   â”‚  11
  â”‚  1 â”‚  1 â”‚  0 â”‚  0 â”‚  X   â”‚  12
  â”‚  1 â”‚  1 â”‚  0 â”‚  1 â”‚  X   â”‚  13
  â”‚  1 â”‚  1 â”‚  1 â”‚  0 â”‚  X   â”‚  14
  â”‚  1 â”‚  1 â”‚  1 â”‚  1 â”‚  X   â”‚  15
  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
```

### Step 2: K-Map (with don't cares)

```
                CD
            00     01     11     10
         â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  AB=00  â”‚  0   â”‚  0   â”‚  0   â”‚  0   â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  AB=01  â”‚  0   â”‚  0   â”‚  1   â”‚  1   â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  AB=11  â”‚  X   â”‚  X   â”‚  X   â”‚  X   â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
  AB=10  â”‚  1   â”‚  1   â”‚  X   â”‚  X   â”‚
         â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
  
  Groups (using don't cares as 1s):
  
  Group 1: {mâ‚†,mâ‚‡,mâ‚â‚„,mâ‚â‚…} + {mâ‚â‚‚,mâ‚â‚ƒ,mâ‚â‚„,mâ‚â‚…}
           Combine: mâ‚†,mâ‚‡,mâ‚â‚‚,mâ‚â‚ƒ,mâ‚â‚„,mâ‚â‚… â†’ BC
           Wait, let me be precise.
           mâ‚†(0110),mâ‚‡(0111),mâ‚â‚„(1110),mâ‚â‚…(1111): B=1,C=1 â†’ BC
  
  Group 2: mâ‚ˆ,mâ‚‰,mâ‚â‚€,mâ‚â‚,mâ‚â‚‚,mâ‚â‚ƒ,mâ‚â‚„,mâ‚â‚… â†’ all of row AB=10,11 â†’ A
           mâ‚ˆ(1000),mâ‚‰(1001),mâ‚â‚€(1010),mâ‚â‚(1011): A=1, B=0
           mâ‚â‚‚-mâ‚â‚…: A=1, B=1
           All have A=1 â†’ A (group of 8)
  
  f = A + BC
```

### Step 3: Circuit

```
  B â”€â”€â”€â”€â”€â”€â”
          â”‚ AND â”œâ”€â”€â”€â”€â”€â”€â”
  C â”€â”€â”€â”€â”€â”€â”˜            â”‚
                       â”‚ OR â”œâ”€â”€â”€â”€ f = A + BC
  A â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  Gate count: 1 AND + 1 OR = 2 gates
  Gate inputs: 4
```

### Step 4: Verify

```
  f = A + BC
  
  Input 6  (0110): A=0, BC=1Â·1=1 â†’ f=1 âœ“
  Input 7  (0111): A=0, BC=1Â·1=1 â†’ f=1 âœ“
  Input 8  (1000): A=1           â†’ f=1 âœ“
  Input 9  (1001): A=1           â†’ f=1 âœ“
  Input 5  (0101): A=0, BC=1Â·0=0 â†’ f=0 âœ“
  Input 0-4: A=0, BC â‰¤ 1Â·0=0     â†’ f=0 âœ“
```

---

## 10. Comparator

A **1-bit comparator** compares two bits $A$ and $B$:

```
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ A â”‚ B â”‚ A > B â”‚ A = B â”‚ A < B â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0 â”‚ 0 â”‚   0   â”‚   1   â”‚   0   â”‚
  â”‚ 0 â”‚ 1 â”‚   0   â”‚   0   â”‚   1   â”‚
  â”‚ 1 â”‚ 0 â”‚   1   â”‚   0   â”‚   0   â”‚
  â”‚ 1 â”‚ 1 â”‚   0   â”‚   1   â”‚   0   â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
  
  A > B  =  A Â· BÌ„
  A = B  =  A âŠ™ B  =  (A âŠ• B)'
  A < B  =  Ä€ Â· B
  
  Circuit:
  
  A â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ANDâ‚ (with BÌ„) â”€â”€â”€â”€ A>B
      â”‚
      â”œâ”€â”€â”€â”€ XOR â”€â”€ NOT â”€â”€â”€â”€ A=B
      â”‚      â†‘
  B â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â””â”€â”€ NOT â”€â”€â”€â”€ ANDâ‚‚ (with B) â”€â”€â”€â”€ A<B
```

---

## ğŸ“ Summary Table

| Circuit | Inputs â†’ Outputs | Key Expression |
|---------|:----------------:|:--------------:|
| Half Adder | A,B â†’ S,C | $S=A \oplus B$, $C=AB$ |
| Full Adder | A,B,Cáµ¢â‚™ â†’ S,Câ‚’áµ¤â‚œ | $S=A \oplus B \oplus C_{in}$, $C_{out}=AB+(A \oplus B)C_{in}$ |
| Half Subtractor | A,B â†’ D,Bâ‚’áµ¤â‚œ | $D=A \oplus B$, $B_{out}=\overline{A}B$ |
| 2-to-1 MUX | Iâ‚€,Iâ‚,S â†’ Y | $Y=\overline{S}I_0 + SI_1$ |
| 2-to-4 Decoder | Aâ‚,Aâ‚€ â†’ Dâ‚€-Dâ‚ƒ | $D_i = $ minterm $m_i$ |
| Comparator | A,B â†’ >,=,< | $A>B = A\overline{B}$ |

| Design Concept | Key Idea |
|---------------|----------|
| Design flow | Spec â†’ Truth table â†’ SOP â†’ K-map â†’ Circuit |
| Don't cares | Use X values to make larger K-map groups |
| MUX as function gen | $2^{n-1}$-to-1 MUX implements any $n$-var function |
| Decoder + OR | Decoder generates minterms; OR selects them |
| Timing diagram | Shows signal transitions over time |
| Propagation delay | NAND/NOR faster than AND/OR |

---

## â“ Quick Revision Questions

1. **Design a Full Subtractor (A - B - Báµ¢â‚™) â€” create the truth table and derive the expressions for Difference and Borrow-out.**

2. **Implement $f(A,B,C) = \sum m(0, 3, 5, 6)$ using a 3-to-8 decoder and an OR gate.**

3. **Implement $f(A,B,C) = \sum m(1, 2, 6, 7)$ using a 4-to-1 MUX with A,B as select lines.**

4. **How many Full Adders are needed to build an 8-bit adder? What is the worst-case carry propagation delay?**

5. **Draw the timing diagram for a NOR gate with inputs A and B, where A toggles every 10ns and B toggles every 20ns, starting from time 0 with both LOW.**

6. **Design a circuit that outputs 1 when a 4-bit input is a prime number (2,3,5,7,11,13). Use a K-map with don't cares for inputs 10-15.**

---

[â† Previous: Logic Gates](04-logic-gates.md) | [Back to README](../README.md)
