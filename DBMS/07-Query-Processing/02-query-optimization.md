# Chapter 7.2: Query Optimization

[â† Back to Table of Contents](../README.md)

---

## ğŸ“š Chapter Overview

**Query optimization** transforms a query into the most efficient execution plan. The optimizer evaluates multiple strategies and selects the one with lowest estimated cost.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CHAPTER LEARNING GOALS                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ Understand heuristic query optimization                      â”‚
â”‚  â€¢ Learn query tree transformation rules                        â”‚
â”‚  â€¢ Understand cost-based optimization                           â”‚
â”‚  â€¢ Learn about execution plan selection                         â”‚
â”‚  â€¢ Understand how to read execution plans                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Optimization Approaches

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPTIMIZATION STRATEGIES                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Two main approaches to query optimization:
    

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   1. HEURISTIC (Rule-Based) OPTIMIZATION                        â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”‚
    â”‚   â€¢ Apply transformation RULES that usually improve queries     â”‚
    â”‚   â€¢ No cost estimation needed                                   â”‚
    â”‚   â€¢ Fast optimization                                           â”‚
    â”‚   â€¢ May not find absolute best plan                             â”‚
    â”‚                                                                  â”‚
    â”‚   Examples:                                                      â”‚
    â”‚   â€¢ Push selections down the tree                               â”‚
    â”‚   â€¢ Perform projections early                                   â”‚
    â”‚   â€¢ Convert Cartesian products + selections to joins            â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   2. COST-BASED OPTIMIZATION                                    â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
    â”‚   â€¢ Generate multiple alternative plans                         â”‚
    â”‚   â€¢ Estimate COST of each plan                                  â”‚
    â”‚   â€¢ Select plan with lowest estimated cost                     â”‚
    â”‚                                                                  â”‚
    â”‚   Requires:                                                      â”‚
    â”‚   â€¢ Statistics about data (catalog information)                 â”‚
    â”‚   â€¢ Cost formulas for each operation                            â”‚
    â”‚   â€¢ Search strategy for plan space                              â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    MODERN SYSTEMS USE BOTH:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Query                                                          â”‚
    â”‚     â”‚                                                            â”‚
    â”‚     â†“                                                            â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
    â”‚   â”‚ Heuristic Optimizationâ”‚  â† Apply transformation rules       â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
    â”‚               â”‚                                                  â”‚
    â”‚               â†“                                                  â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
    â”‚   â”‚ Cost-Based Optimizationâ”‚ â† Choose best among alternatives   â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
    â”‚               â”‚                                                  â”‚
    â”‚               â†“                                                  â”‚
    â”‚         Best Plan                                                â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Heuristic Optimization Rules

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EQUIVALENCE RULES                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Transformation rules that preserve query result:
    

    RULE 1: CASCADE OF SELECTIONS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Ïƒ(c1 AND c2)(R)  â‰¡  Ïƒ(c1)(Ïƒ(c2)(R))
    
    Split conjunction into separate selections:
    
    Before:                          After:
    
         Ïƒ(A=1 AND B>5)                  Ïƒ(A=1)
              â”‚                            â”‚
              R                         Ïƒ(B>5)
                                          â”‚
                                          R


    RULE 2: COMMUTATIVITY OF SELECTION
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Ïƒ(c1)(Ïƒ(c2)(R))  â‰¡  Ïƒ(c2)(Ïƒ(c1)(R))
    
    Order of selections doesn't matter:
    
         Ïƒ(A=1)                        Ïƒ(B>5)
           â”‚                â‰¡            â”‚
        Ïƒ(B>5)                        Ïƒ(A=1)
           â”‚                             â”‚
           R                             R


    RULE 3: CASCADE OF PROJECTIONS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Ï€(L1)(Ï€(L2)(...(Ï€(Ln)(R))...))  â‰¡  Ï€(L1)(R)
    
    Only outermost projection matters (if L1 âŠ† L2 âŠ† ... âŠ† Ln):
    
         Ï€(A)                          Ï€(A)
           â”‚              â‰¡              â”‚
        Ï€(A,B)                           R
           â”‚
        Ï€(A,B,C)
           â”‚
           R


    RULE 4: COMMUTING SELECTION WITH PROJECTION
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    If condition c only involves attributes in L:
    
    Ï€(L)(Ïƒ(c)(R))  â‰¡  Ïƒ(c)(Ï€(L)(R))
    
         Ï€(name)                     Ïƒ(age>30)
            â”‚              â‰¡            â”‚
      Ïƒ(age>30)                    Ï€(name,age)    â† must keep 'age'
            â”‚                           â”‚
            R                           R


    RULE 5: COMMUTATIVITY OF JOINS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    R â‹ˆ S  â‰¡  S â‹ˆ R
    
    Join order can be swapped:
    
         â‹ˆ                             â‹ˆ
        / \           â‰¡               / \
       R   S                         S   R


    RULE 6: ASSOCIATIVITY OF JOINS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    (R â‹ˆ S) â‹ˆ T  â‰¡  R â‹ˆ (S â‹ˆ T)
    
    Can regroup joins:
    
           â‹ˆ                           â‹ˆ
          / \                         / \
         â‹ˆ   T        â‰¡              R   â‹ˆ
        / \                             / \
       R   S                           S   T


    RULE 7: COMMUTING SELECTION WITH JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    If c only involves attributes of R:
    
    Ïƒ(c)(R â‹ˆ S)  â‰¡  Ïƒ(c)(R) â‹ˆ S
    
    PUSH SELECTION DOWN!
    
            Ïƒ(R.A=5)                    â‹ˆ
                â”‚                      / \
                â‹ˆ           â‰¡     Ïƒ(A=5)  S
               / \                   â”‚
              R   S                  R


    RULE 8: COMMUTING PROJECTION WITH JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Ï€(L)(R â‹ˆ S) â‰¡ Ï€(L)( Ï€(L1)(R) â‹ˆ Ï€(L2)(S) )
    
    where L1 = attributes of L from R + join attributes
          L2 = attributes of L from S + join attributes
    
    Push projections down:
    
         Ï€(R.A, S.B)                Ï€(R.A, S.B)
              â”‚                          â”‚
              â‹ˆ               â‰¡          â‹ˆ
             / \                        / \
            R   S              Ï€(A,id)   Ï€(B,id)
                                 â”‚         â”‚
                                 R         S
```

---

## 3. Heuristic Optimization Algorithm

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HEURISTIC OPTIMIZATION STEPS                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Standard heuristic optimization algorithm:
    

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   STEP 1: DECOMPOSE SELECTIONS                                  â”‚
    â”‚   Split conjunctive conditions into separate Ïƒ operators        â”‚
    â”‚                                                                  â”‚
    â”‚   STEP 2: PUSH SELECTIONS DOWN                                  â”‚
    â”‚   Move Ïƒ as close to leaves as possible                         â”‚
    â”‚   (Reduce tuple count early!)                                   â”‚
    â”‚                                                                  â”‚
    â”‚   STEP 3: REARRANGE LEAF NODES                                  â”‚
    â”‚   Order for most restrictive joins first                        â”‚
    â”‚                                                                  â”‚
    â”‚   STEP 4: COMBINE CARTESIAN + SELECTION â†’ JOIN                  â”‚
    â”‚   Ïƒ(R.A = S.B)(R Ã— S) â†’ R â‹ˆ(A=B) S                              â”‚
    â”‚                                                                  â”‚
    â”‚   STEP 5: PUSH PROJECTIONS DOWN                                 â”‚
    â”‚   Project away unneeded attributes early                        â”‚
    â”‚   (Reduce tuple width!)                                         â”‚
    â”‚                                                                  â”‚
    â”‚   STEP 6: IDENTIFY COMMON SUBEXPRESSIONS                        â”‚
    â”‚   Compute shared subtrees only once                             â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    EXAMPLE TRANSFORMATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT e.name 
           FROM employees e, departments d
           WHERE e.dept_id = d.id 
             AND e.salary > 50000 
             AND d.location = 'NYC'
    
    
    INITIAL (Canonical) Tree:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€(e.name)
                        â”‚
            Ïƒ(e.dept_id=d.id AND 
              e.salary>50000 AND 
              d.location='NYC')
                        â”‚
                        Ã—
                       / \
                      e   d
    
    
    STEP 1: Decompose Selections
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€(e.name)
                        â”‚
                Ïƒ(e.dept_id=d.id)
                        â”‚
                Ïƒ(e.salary>50000)
                        â”‚
                Ïƒ(d.location='NYC')
                        â”‚
                        Ã—
                       / \
                      e   d
    
    
    STEP 2: Push Selections Down
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€(e.name)
                        â”‚
                Ïƒ(e.dept_id=d.id)
                        â”‚
                        Ã—
                       / \
                      /   \
            Ïƒ(salary>50000) Ïƒ(location='NYC')
                   â”‚              â”‚
                   e              d
    
    
    STEP 3: Combine Ã— + Ïƒ â†’ â‹ˆ
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€(e.name)
                        â”‚
                        â‹ˆ  (dept_id = id)
                       / \
                      /   \
            Ïƒ(salary>50000) Ïƒ(location='NYC')
                   â”‚              â”‚
                   e              d
    
    
    STEP 4: Push Projections
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€(name)
                        â”‚
                        â‹ˆ  (dept_id = id)
                       / \
                      /   \
            Ï€(name,dept_id)  Ï€(id)
                   â”‚              â”‚
            Ïƒ(salary>50000) Ïƒ(location='NYC')
                   â”‚              â”‚
                   e              d
    
    
    RESULT:
    â”€â”€â”€â”€â”€â”€â”€â”€
    
    â€¢ Selections applied BEFORE join (fewer tuples to join)
    â€¢ Projections reduce tuple width before join
    â€¢ Much more efficient than Cartesian product!
```

---

## 4. Cost-Based Optimization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COST-BASED OPTIMIZATION                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    After heuristic optimization, cost-based optimizer chooses
    the BEST IMPLEMENTATION for remaining choices.
    

    CHOICES TO MAKE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   1. ACCESS METHOD for each table                               â”‚
    â”‚      â€¢ Full table scan?                                         â”‚
    â”‚      â€¢ Use index A? Index B?                                    â”‚
    â”‚      â€¢ Which index if multiple available?                       â”‚
    â”‚                                                                  â”‚
    â”‚   2. JOIN ALGORITHM for each join                               â”‚
    â”‚      â€¢ Nested loop? Sort-merge? Hash?                           â”‚
    â”‚      â€¢ Which table as outer vs inner?                           â”‚
    â”‚                                                                  â”‚
    â”‚   3. JOIN ORDER for multiple tables                             â”‚
    â”‚      â€¢ (A â‹ˆ B) â‹ˆ C  or  A â‹ˆ (B â‹ˆ C)?                          â”‚
    â”‚      â€¢ For n tables, there are (n-1)! orderings!               â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    PLAN ENUMERATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Query: A â‹ˆ B â‹ˆ C                                              â”‚
    â”‚                                                                  â”‚
    â”‚   Join orders: (Aâ‹ˆB)â‹ˆC,  (Aâ‹ˆC)â‹ˆB,  (Bâ‹ˆC)â‹ˆA                    â”‚
    â”‚                Aâ‹ˆ(Bâ‹ˆC),  Aâ‹ˆ(Câ‹ˆB),  Bâ‹ˆ(Aâ‹ˆC), ...               â”‚
    â”‚                                                                  â”‚
    â”‚   For each order, choose join algorithm:                        â”‚
    â”‚   â€¢ Nested loop, sort-merge, hash                               â”‚
    â”‚                                                                  â”‚
    â”‚   For each table access, choose method:                         â”‚
    â”‚   â€¢ Full scan, index1, index2...                                â”‚
    â”‚                                                                  â”‚
    â”‚   EXPLOSION of possibilities!                                   â”‚
    â”‚                                                                  â”‚
    â”‚   4 tables: hundreds of plans                                   â”‚
    â”‚   10 tables: millions of plans                                  â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    DYNAMIC PROGRAMMING APPROACH:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   System R algorithm (foundation of most optimizers):           â”‚
    â”‚                                                                  â”‚
    â”‚   1. Find best plan for each single table access               â”‚
    â”‚                                                                  â”‚
    â”‚   2. Find best plan for each pair of tables                    â”‚
    â”‚      (using results from step 1)                                â”‚
    â”‚                                                                  â”‚
    â”‚   3. Find best plan for each triple                            â”‚
    â”‚      (using results from step 2)                                â”‚
    â”‚                                                                  â”‚
    â”‚   4. Continue until all tables combined                        â”‚
    â”‚                                                                  â”‚
    â”‚   Key insight: Best plan for subset is independent of how      â”‚
    â”‚                that subset is used in larger plans              â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    
    EXAMPLE: Optimize A â‹ˆ B â‹ˆ C
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Step 1: Single table access
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   A: scan=100, index=5     â†’ Best: index (cost 5)              â”‚
    â”‚   B: scan=200              â†’ Best: scan (cost 200)             â”‚
    â”‚   C: scan=50, index=10     â†’ Best: index (cost 10)             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Step 2: Join pairs
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Aâ‹ˆB: hash=150, nested=500    â†’ Best: hash (cost 150)         â”‚
    â”‚   Bâ‹ˆC: hash=180, merge=200     â†’ Best: hash (cost 180)         â”‚
    â”‚   Aâ‹ˆC: hash=40, nested=100     â†’ Best: hash (cost 40)          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Step 3: All three
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   (Aâ‹ˆB)â‹ˆC: best(Aâ‹ˆB) + best(join with C) = 150 + 80 = 230     â”‚
    â”‚   (Aâ‹ˆC)â‹ˆB: best(Aâ‹ˆC) + best(join with B) = 40 + 120 = 160     â”‚
    â”‚   (Bâ‹ˆC)â‹ˆA: best(Bâ‹ˆC) + best(join with A) = 180 + 100 = 280    â”‚
    â”‚                                                                  â”‚
    â”‚   Best plan: (Aâ‹ˆC)â‹ˆB with cost 160                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    INTERESTING ORDERS:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Sometimes a more expensive plan is better if it produces
    SORTED output that benefits later operations:
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Query: SELECT * FROM A â‹ˆ B â‹ˆ C ORDER BY A.x                  â”‚
    â”‚                                                                  â”‚
    â”‚   Plan 1: Hash join Aâ‹ˆB, then hash join with C                 â”‚
    â”‚           Cost: 300, then sort for ORDER BY: +100 = 400        â”‚
    â”‚                                                                  â”‚
    â”‚   Plan 2: Sort-merge join Aâ‹ˆB (output sorted on A.x!)          â”‚
    â”‚           Cost: 350, no extra sort needed = 350                â”‚
    â”‚                                                                  â”‚
    â”‚   Plan 2 wins despite more expensive join!                     â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Execution Plans

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    UNDERSTANDING EXECUTION PLANS                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Most databases allow you to VIEW the execution plan:
    
    â€¢ PostgreSQL: EXPLAIN / EXPLAIN ANALYZE
    â€¢ MySQL: EXPLAIN / EXPLAIN FORMAT=TREE
    â€¢ SQL Server: SET SHOWPLAN_ALL ON / execution plan viewer
    â€¢ Oracle: EXPLAIN PLAN FOR
    

    EXAMPLE PLAN (PostgreSQL style):
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT e.name, d.dept_name
           FROM employees e JOIN departments d ON e.dept_id = d.id
           WHERE e.salary > 50000
    
    
    EXPLAIN output:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Hash Join  (cost=10.50..150.00 rows=100)                      â”‚
    â”‚     Hash Cond: (e.dept_id = d.id)                               â”‚
    â”‚     ->  Seq Scan on employees e  (cost=0..80.00 rows=500)      â”‚
    â”‚           Filter: (salary > 50000)                              â”‚
    â”‚     ->  Hash  (cost=5.00..5.00 rows=50)                        â”‚
    â”‚           ->  Seq Scan on departments d  (cost=0..5.00 rows=50)â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    
    Reading the plan (bottom-up):
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Level 3: Seq Scan departments                                 â”‚
    â”‚            Full table scan, reads all 50 rows                   â”‚
    â”‚                                                                  â”‚
    â”‚   Level 2: Hash                                                 â”‚
    â”‚            Build hash table from departments                    â”‚
    â”‚                                                                  â”‚
    â”‚   Level 2: Seq Scan employees + Filter                          â”‚
    â”‚            Full scan with filter salary > 50000                 â”‚
    â”‚            Expects ~500 rows after filter                       â”‚
    â”‚                                                                  â”‚
    â”‚   Level 1: Hash Join                                            â”‚
    â”‚            Probe employees against departments hash             â”‚
    â”‚            Expects ~100 result rows                             â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    VISUAL PLAN REPRESENTATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
    â”‚                    â”‚   Hash Join     â”‚ â† Final output           â”‚
    â”‚                    â”‚   cost: 150     â”‚                          â”‚
    â”‚                    â”‚   rows: 100     â”‚                          â”‚
    â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
    â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                            â”‚
    â”‚                      â”‚             â”‚                            â”‚
    â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
    â”‚              â”‚  Seq Scan    â”‚  â”‚      Hash      â”‚              â”‚
    â”‚              â”‚  employees   â”‚  â”‚    cost: 5     â”‚              â”‚
    â”‚              â”‚  + Filter    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
    â”‚              â”‚  cost: 80    â”‚          â”‚                        â”‚
    â”‚              â”‚  rows: 500   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
    â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   Seq Scan     â”‚              â”‚
    â”‚                                â”‚  departments   â”‚              â”‚
    â”‚                                â”‚   cost: 5      â”‚              â”‚
    â”‚                                â”‚   rows: 50     â”‚              â”‚
    â”‚                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COMMON PLAN OPERATORS:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚      Operator          â”‚              Description                â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Seq Scan               â”‚ Full table scan                         â”‚
    â”‚ Index Scan             â”‚ B+-tree traversal                       â”‚
    â”‚ Index Only Scan        â”‚ Index covers all needed columns        â”‚
    â”‚ Bitmap Index Scan      â”‚ Build bitmap, then fetch rows          â”‚
    â”‚ Nested Loop            â”‚ Nested loop join                        â”‚
    â”‚ Hash Join              â”‚ Hash join                               â”‚
    â”‚ Merge Join             â”‚ Sort-merge join                         â”‚
    â”‚ Sort                   â”‚ Sort operation                          â”‚
    â”‚ Aggregate              â”‚ GROUP BY / aggregation                  â”‚
    â”‚ Hash Aggregate         â”‚ Aggregation using hashing               â”‚
    â”‚ Limit                  â”‚ LIMIT clause                            â”‚
    â”‚ Materialize            â”‚ Store intermediate results              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COST NUMBERS EXPLAINED:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    cost=10.50..150.00
         â†‘         â†‘
     startup    total
      cost      cost
    
    â€¢ Startup cost: Time before first row returned
    â€¢ Total cost: Time to return all rows
    
    rows=100
    â€¢ Estimated number of output rows
    
    width=50
    â€¢ Estimated average row width in bytes
```

---

## 6. Optimization Tips

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HELPING THE OPTIMIZER                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Sometimes the optimizer makes suboptimal choices.
    Here's how to help:
    

    1. MAINTAIN STATISTICS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   -- PostgreSQL                                                 â”‚
    â”‚   ANALYZE table_name;                                           â”‚
    â”‚                                                                  â”‚
    â”‚   -- MySQL                                                      â”‚
    â”‚   ANALYZE TABLE table_name;                                     â”‚
    â”‚                                                                  â”‚
    â”‚   -- Run after bulk loads or major changes                     â”‚
    â”‚   -- Gives optimizer accurate row counts and distributions     â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    2. CREATE APPROPRIATE INDEXES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Index columns used in:                                        â”‚
    â”‚   â€¢ WHERE clauses                                               â”‚
    â”‚   â€¢ JOIN conditions                                             â”‚
    â”‚   â€¢ ORDER BY clauses                                            â”‚
    â”‚                                                                  â”‚
    â”‚   Consider composite indexes for multi-column conditions:      â”‚
    â”‚   CREATE INDEX idx ON orders(customer_id, order_date);         â”‚
    â”‚                                                                  â”‚
    â”‚   Matches: WHERE customer_id = X AND order_date > Y            â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    3. WRITE SARGABLE QUERIES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    SARGABLE = Search ARGument ABLE (can use index)
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   BAD (Non-sargable):                                           â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
    â”‚   WHERE YEAR(order_date) = 2024                                â”‚
    â”‚   WHERE salary * 2 > 100000                                    â”‚
    â”‚   WHERE name LIKE '%smith'                                     â”‚
    â”‚   WHERE UPPER(email) = 'TEST@EXAMPLE.COM'                      â”‚
    â”‚                                                                  â”‚
    â”‚   Function on column â†’ Can't use index!                        â”‚
    â”‚                                                                  â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                                                                  â”‚
    â”‚   GOOD (Sargable):                                              â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
    â”‚   WHERE order_date >= '2024-01-01'                             â”‚
    â”‚         AND order_date < '2025-01-01'                          â”‚
    â”‚   WHERE salary > 50000                                         â”‚
    â”‚   WHERE name LIKE 'smith%'                                     â”‚
    â”‚   WHERE email = 'test@example.com'                             â”‚
    â”‚         (store lowercase, compare lowercase)                    â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    4. AVOID SELECT *
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   BAD:                                                          â”‚
    â”‚   SELECT * FROM employees WHERE dept = 'IT';                   â”‚
    â”‚   â€¢ Fetches all columns (even unneeded)                        â”‚
    â”‚   â€¢ Can't use index-only scan                                  â”‚
    â”‚                                                                  â”‚
    â”‚   GOOD:                                                         â”‚
    â”‚   SELECT id, name FROM employees WHERE dept = 'IT';            â”‚
    â”‚   â€¢ May enable index-only scan (covering index)                â”‚
    â”‚   â€¢ Less data to transfer                                       â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    5. BE CAREFUL WITH OUTER JOINS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   LEFT JOIN is less flexible for optimization than INNER JOIN  â”‚
    â”‚                                                                  â”‚
    â”‚   Optimizer can't reorder:                                      â”‚
    â”‚   A LEFT JOIN B LEFT JOIN C                                    â”‚
    â”‚                                                                  â”‚
    â”‚   But can reorder:                                              â”‚
    â”‚   A INNER JOIN B INNER JOIN C                                  â”‚
    â”‚                                                                  â”‚
    â”‚   Use INNER JOIN when you don't need NULL-extended rows        â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    6. USE QUERY HINTS SPARINGLY
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Force index:                                                   â”‚
    â”‚   -- MySQL                                                      â”‚
    â”‚   SELECT * FROM t FORCE INDEX (idx) WHERE ...;                 â”‚
    â”‚                                                                  â”‚
    â”‚   -- PostgreSQL (using set_)                                   â”‚
    â”‚   SET enable_seqscan = off;                                    â”‚
    â”‚                                                                  â”‚
    â”‚   -- SQL Server                                                 â”‚
    â”‚   SELECT * FROM t WITH (INDEX(idx)) WHERE ...;                 â”‚
    â”‚                                                                  â”‚
    â”‚   âš ï¸  Use only when optimizer consistently wrong!              â”‚
    â”‚   Better to fix statistics or query structure                  â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Summary Table

| Optimization Type | Description | Speed |
|-------------------|-------------|-------|
| **Heuristic** | Apply transformation rules | Fast |
| **Cost-Based** | Estimate costs, pick cheapest | Slower but better |
| **Hybrid** | Rules first, then cost-based | Used in practice |

| Heuristic Rule | Effect |
|----------------|--------|
| **Push selection down** | Filter early, fewer tuples |
| **Push projection down** | Narrow tuples early |
| **Combine Ã— + Ïƒ â†’ â‹ˆ** | Replace Cartesian with join |
| **Reorder joins** | Most selective first |

| Plan Operator | Description |
|---------------|-------------|
| **Seq Scan** | Full table scan |
| **Index Scan** | Use B+-tree |
| **Hash Join** | Build + probe hash |
| **Merge Join** | Sort + merge |
| **Nested Loop** | For each outer, scan inner |

---

## â“ Quick Revision Questions

1. **What is the main difference between heuristic and cost-based optimization?**
   <details>
   <summary>Click for Answer</summary>
   Heuristic optimization applies transformation rules that usually improve performance (like pushing selections down), without estimating actual costs. Cost-based optimization generates multiple alternative plans, estimates each plan's cost using statistics, and selects the cheapest. Modern systems use both.
   </details>

2. **Why is "push selections down" an important heuristic rule?**
   <details>
   <summary>Click for Answer</summary>
   Selections reduce the number of tuples. By pushing them down (applying them earlier in the query tree, close to base tables), we reduce the input size for subsequent operations like joins. Joining 100 filtered rows is much cheaper than joining 10,000 rows then filtering.
   </details>

3. **How does the optimizer handle n-way joins efficiently?**
   <details>
   <summary>Click for Answer</summary>
   Using dynamic programming: first find optimal plans for each single table, then for each pair using those results, then for triples, etc. This avoids recomputing the same subproblems and reduces exponential complexity. Only need to consider optimal subplans, not all possible plans.
   </details>

4. **What is an "interesting order" in query optimization?**
   <details>
   <summary>Click for Answer</summary>
   An interesting order is a sort order that benefits later operations. A more expensive plan that produces sorted output might be better overall if it avoids a later sort. Example: sort-merge join is costlier than hash join, but if ORDER BY matches the join key, total cost may be lower.
   </details>

5. **What makes a query non-sargable?**
   <details>
   <summary>Click for Answer</summary>
   A query is non-sargable when a function or expression is applied to an indexed column: WHERE YEAR(date) = 2024, WHERE salary + bonus > 100000, WHERE name LIKE '%smith'. The index stores original values, not function results, so it can't be used. Rewrite to apply functions to constants instead.
   </details>

6. **How do you read an execution plan's cost estimates?**
   <details>
   <summary>Click for Answer</summary>
   Cost shows as "startup_cost..total_cost". Startup cost is work before first row is returned; total cost is work for all rows. Reading bottom-up: leaf nodes (table accesses) execute first, results flow up to parent operators. Compare costs between alternative plans to understand optimizer's choices.
   </details>

---

## ğŸ”— Navigation

| Previous | Up | Next |
|----------|----|----|
| [â† Query Processing Basics](01-query-processing-basics.md) | [ğŸ“š Table of Contents](../README.md) | [Distributed Databases â†’](../08-Advanced-Topics/01-distributed-databases.md) |

---

*Last Updated: January 2026*
