# Chapter 7.1: Query Processing Basics

[â† Back to Table of Contents](../README.md)

---

## ğŸ“š Chapter Overview

**Query processing** transforms SQL queries into efficient execution plans. Understanding how queries are processed helps write better SQL and understand database performance.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CHAPTER LEARNING GOALS                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ Understand the query processing pipeline                     â”‚
â”‚  â€¢ Learn parsing and validation steps                           â”‚
â”‚  â€¢ Understand query representation (query trees)                â”‚
â”‚  â€¢ Learn basic algorithms for SELECT, JOIN, PROJECT            â”‚
â”‚  â€¢ Understand cost estimation basics                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Query Processing Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    QUERY PROCESSING PIPELINE                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    SQL Query â†’ ... â†’ Result
    
    What happens in between?
    

    THE COMPLETE PIPELINE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   User Query (SQL)                                               â”‚
    â”‚         â”‚                                                        â”‚
    â”‚         â†“                                                        â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
    â”‚   â”‚    PARSING      â”‚  Syntax check, build parse tree           â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
    â”‚            â”‚                                                     â”‚
    â”‚            â†“                                                     â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
    â”‚   â”‚   VALIDATION    â”‚  Check tables, columns, permissions       â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
    â”‚            â”‚                                                     â”‚
    â”‚            â†“                                                     â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
    â”‚   â”‚   TRANSLATION   â”‚  Convert to internal representation       â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  (relational algebra / query tree)        â”‚
    â”‚            â”‚                                                     â”‚
    â”‚            â†“                                                     â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
    â”‚   â”‚  OPTIMIZATION   â”‚  Find efficient execution plan            â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
    â”‚            â”‚                                                     â”‚
    â”‚            â†“                                                     â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
    â”‚   â”‚   EXECUTION     â”‚  Run the plan, fetch data                 â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
    â”‚            â”‚                                                     â”‚
    â”‚            â†“                                                     â”‚
    â”‚       Query Results                                              â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    EXAMPLE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT name FROM employees WHERE dept = 'Sales'
    
    1. PARSING:    Check SQL syntax is correct
    2. VALIDATION: Verify 'employees' table exists
                   Verify 'name', 'dept' columns exist
                   Check user has SELECT permission
    3. TRANSLATION: Ïƒ(dept='Sales')(employees) â†’ Ï€(name)
    4. OPTIMIZATION: Should we use index on dept?
                     How many rows match 'Sales'?
    5. EXECUTION:  Actually fetch the matching rows
```

---

## 2. Parsing and Validation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PARSING PHASE                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Parser checks SQL SYNTAX and builds a PARSE TREE.
    

    PARSE TREE EXAMPLE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT name, salary 
           FROM employees 
           WHERE dept = 'IT' AND salary > 50000
    
    
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    SELECT_STMT   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                    â”‚                    â”‚
            â†“                    â†“                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ SELECT_LIST  â”‚     â”‚  FROM_CLAUSE â”‚     â”‚ WHERE_CLAUSE â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                    â”‚                    â”‚
       â”Œâ”€â”€â”€â”´â”€â”€â”€â”                â†“                    â†“
       â†“       â†“         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”     â”‚ employees  â”‚       â”‚    AND     â”‚
    â”‚name â”‚ â”‚salaryâ”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜                          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                                              â†“           â†“
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚dept='IT'â”‚ â”‚salary>50K â”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    SYNTAX ERRORS CAUGHT:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   SELEC name FROM employees     â† Misspelled keyword           â”‚
    â”‚   ERROR: Unknown command 'SELEC'                                â”‚
    â”‚                                                                  â”‚
    â”‚   SELECT name FROM employees WERE dept = 'IT'                   â”‚
    â”‚   ERROR: Expected 'WHERE', found 'WERE'                         â”‚
    â”‚                                                                  â”‚
    â”‚   SELECT name, FROM employees   â† Dangling comma               â”‚
    â”‚   ERROR: Unexpected 'FROM' after ','                            â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VALIDATION PHASE                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Semantic analysis using SYSTEM CATALOG (metadata).
    

    CHECKS PERFORMED:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   1. TABLE EXISTENCE                                            â”‚
    â”‚      Does 'employees' table exist in database?                  â”‚
    â”‚                                                                  â”‚
    â”‚   2. COLUMN EXISTENCE                                           â”‚
    â”‚      Do 'name', 'salary', 'dept' exist in 'employees'?         â”‚
    â”‚                                                                  â”‚
    â”‚   3. COLUMN AMBIGUITY (for JOINs)                              â”‚
    â”‚      SELECT id FROM A, B  â† Which table's id?                  â”‚
    â”‚                                                                  â”‚
    â”‚   4. TYPE COMPATIBILITY                                         â”‚
    â”‚      salary > 'fifty'  â† Comparing number to string?           â”‚
    â”‚                                                                  â”‚
    â”‚   5. PERMISSIONS                                                â”‚
    â”‚      Does user have SELECT privilege on this table?            â”‚
    â”‚                                                                  â”‚
    â”‚   6. AGGREGATE VALIDITY                                         â”‚
    â”‚      SELECT dept, name, COUNT(*)  â† name not in GROUP BY       â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    SYSTEM CATALOG LOOKUP:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   System Catalog Tables:                                        â”‚
    â”‚                                                                  â”‚
    â”‚   TABLES                    COLUMNS                             â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚   â”‚ table_name â”‚ owner â”‚    â”‚ table â”‚ column â”‚ type â”‚ null â”‚   â”‚
    â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤   â”‚
    â”‚   â”‚ employees  â”‚ admin â”‚    â”‚ emp   â”‚ id     â”‚ INT  â”‚ NO   â”‚   â”‚
    â”‚   â”‚ departmentsâ”‚ admin â”‚    â”‚ emp   â”‚ name   â”‚ VARCHâ”‚ NO   â”‚   â”‚
    â”‚   â”‚ projects   â”‚ pm    â”‚    â”‚ emp   â”‚ salary â”‚ DEC  â”‚ YES  â”‚   â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ emp   â”‚ dept   â”‚ VARCHâ”‚ YES  â”‚   â”‚
    â”‚                             â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚                                                                  â”‚
    â”‚   Validator queries catalog to verify query references         â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Query Trees and Algebra

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    QUERY TREE (OPERATOR TREE)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    After validation, query is converted to RELATIONAL ALGEBRA,
    represented as a QUERY TREE.
    

    RELATIONAL ALGEBRA OPERATORS:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Operator     â”‚              Description                     â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Ïƒ (SELECT)     â”‚ Filter rows: Ïƒ_condition(R)                  â”‚
    â”‚ Ï€ (PROJECT)    â”‚ Choose columns: Ï€_columns(R)                 â”‚
    â”‚ â‹ˆ (JOIN)       â”‚ Combine tables: R â‹ˆ_condition S              â”‚
    â”‚ Ã— (CARTESIAN)  â”‚ All pairs: R Ã— S                             â”‚
    â”‚ âˆª (UNION)      â”‚ Combine rows: R âˆª S                          â”‚
    â”‚ âˆ’ (DIFFERENCE) â”‚ Rows in R not in S: R âˆ’ S                    â”‚
    â”‚ Ï (RENAME)     â”‚ Rename: Ï_new_name(R)                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    QUERY TREE EXAMPLE:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT e.name, d.dept_name
           FROM employees e, departments d
           WHERE e.dept_id = d.id AND e.salary > 50000
    
    
    Initial (Canonical) Query Tree:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
                    Ï€ (e.name, d.dept_name)
                            â”‚
                            â”‚
                    Ïƒ (e.dept_id = d.id AND e.salary > 50000)
                            â”‚
                            â”‚
                          Ã—  (Cartesian Product)
                         / \
                        /   \
                       /     \
                employees   departments
                   (e)          (d)
    
    
    Execution (bottom-up):
    1. Read employees table
    2. Read departments table
    3. Compute Cartesian product (HUGE!)
    4. Filter matching rows
    5. Project needed columns


    PROBLEM:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    If employees has 1000 rows and departments has 50:
    Cartesian product = 1000 Ã— 50 = 50,000 rows!
    Then we filter down to maybe 100 matches.
    
    This is VERY INEFFICIENT!
    â†’ Query optimization will improve this (next chapter)
```

---

## 4. Basic Algorithms for Operations

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SELECTION (Ïƒ) ALGORITHMS                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Selection: Find rows matching a condition.
    

    ALGORITHM 1: LINEAR SEARCH (File Scan)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   For each block in file:                                       â”‚
    â”‚       For each record in block:                                 â”‚
    â”‚           If record matches condition:                          â”‚
    â”‚               Add to result                                     â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: b blocks (read entire file)                             â”‚
    â”‚   Works for ANY condition                                       â”‚
    â”‚   Always available, but slowest                                 â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 2: BINARY SEARCH (on sorted file)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Condition: attribute = value (on sorted attribute)            â”‚
    â”‚                                                                  â”‚
    â”‚   1. Binary search to find first matching block                 â”‚
    â”‚   2. Read consecutive blocks while matches exist                â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: logâ‚‚(b) + (matching blocks)                            â”‚
    â”‚   Requires: File sorted on selection attribute                  â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 3: PRIMARY INDEX (B+-Tree)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Condition: primary_key = value                                â”‚
    â”‚                                                                  â”‚
    â”‚   1. Traverse B+-tree to leaf                                   â”‚
    â”‚   2. Follow pointer to data record                              â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: height + 1 = typically 3-4 reads                        â”‚
    â”‚   Requires: B+-tree index on primary key                        â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 4: SECONDARY INDEX
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Condition: indexed_attr = value                               â”‚
    â”‚                                                                  â”‚
    â”‚   1. Traverse secondary B+-tree                                 â”‚
    â”‚   2. Get list of record pointers                                â”‚
    â”‚   3. Fetch each record (may be scattered!)                      â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: height + (number of matching records)                   â”‚
    â”‚   Note: Each record fetch may be a random I/O!                 â”‚
    â”‚                                                                  â”‚
    â”‚   Good for few matches, bad for many                           â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COMPARISON:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Query: SELECT * FROM employees WHERE dept = 'IT'
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     Method         â”‚     Cost (b=1000 blocks, 50 matches)     â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Linear scan        â”‚ 1000 block reads                          â”‚
    â”‚ Index (clustered)  â”‚ 3 (index) + ~5 (adjacent data) = 8       â”‚
    â”‚ Index (unclustered)â”‚ 3 (index) + 50 (scattered) = 53          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROJECTION (Ï€) ALGORITHMS                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Projection: Select specific columns, eliminate duplicates.
    

    DUPLICATE ELIMINATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Ï€(dept) from employees â†’ unique department values
    
    Method 1: SORTING
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   1. Scan and extract column values                             â”‚
    â”‚   2. Sort the values                                            â”‚
    â”‚   3. Scan sorted list, remove adjacent duplicates              â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: O(n log n) for sorting                                  â”‚
    â”‚                                                                  â”‚
    â”‚   [IT, Sales, IT, HR, IT, Sales]                               â”‚
    â”‚                  â†“ sort                                         â”‚
    â”‚   [HR, IT, IT, IT, Sales, Sales]                               â”‚
    â”‚                  â†“ remove adjacent dups                        â”‚
    â”‚   [HR, IT, Sales]                                               â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Method 2: HASHING
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   1. Hash each projected tuple                                  â”‚
    â”‚   2. Check if already in hash table                            â”‚
    â”‚   3. If not, add to table and output                           â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: O(n) average                                            â”‚
    â”‚                                                                  â”‚
    â”‚   [ITâ†’bucket1, Salesâ†’bucket2, ITâ†’exists!, HRâ†’bucket3...]       â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    JOIN (â‹ˆ) ALGORITHMS                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Join is the MOST EXPENSIVE operation!
    Multiple algorithms with different trade-offs.
    

    ALGORITHM 1: NESTED LOOP JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   For each tuple r in R (outer):                                â”‚
    â”‚       For each tuple s in S (inner):                            â”‚
    â”‚           If r.A = s.B:                                         â”‚
    â”‚               Output (r, s)                                     â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: nR Ã— nS tuple comparisons                               â”‚
    â”‚   Block I/O: bR + (nR Ã— bS)  or  bR Ã— bS (block nested loop)   â”‚
    â”‚                                                                  â”‚
    â”‚   Example: R has 100 tuples, S has 1000                        â”‚
    â”‚   Comparisons: 100 Ã— 1000 = 100,000                            â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    
                   R (outer)              S (inner)
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚   r1    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ s1,s2..snâ”‚ compare all
                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚   r2    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ s1,s2..snâ”‚ compare all
                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚   ...   â”‚              ...
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 2: BLOCK NESTED LOOP JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   For each BLOCK bR of R:                                       â”‚
    â”‚       For each BLOCK bS of S:                                   â”‚
    â”‚           For each tuple r in bR:                               â”‚
    â”‚               For each tuple s in bS:                           â”‚
    â”‚                   If join condition met:                        â”‚
    â”‚                       Output (r, s)                             â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: bR + (bR Ã— bS) block reads                             â”‚
    â”‚   Much better if we can hold outer block in memory!            â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 3: SORT-MERGE JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   1. Sort R on join attribute A                                 â”‚
    â”‚   2. Sort S on join attribute B                                 â”‚
    â”‚   3. Merge: scan both sorted relations simultaneously          â”‚
    â”‚                                                                  â”‚
    â”‚   R (sorted)        S (sorted)                                  â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”                                     â”‚
    â”‚   â”‚ A=1 â”‚           â”‚ B=1 â”‚ â† Match!                           â”‚
    â”‚   â”‚ A=2 â”‚           â”‚ B=1 â”‚ â† Match with A=1                   â”‚
    â”‚   â”‚ A=2 â”‚           â”‚ B=2 â”‚ â† Match!                           â”‚
    â”‚   â”‚ A=4 â”‚           â”‚ B=3 â”‚ â† No match, advance S              â”‚
    â”‚   â”‚ A=5 â”‚           â”‚ B=5 â”‚ â† Match!                           â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”˜                                     â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: Sort(R) + Sort(S) + (bR + bS) for merge                â”‚
    â”‚   Best when: inputs already sorted, or sort can be reused      â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ALGORITHM 4: HASH JOIN
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Phase 1: BUILD (on smaller relation R)                        â”‚
    â”‚            Hash R tuples into buckets on join attribute         â”‚
    â”‚                                                                  â”‚
    â”‚   Phase 2: PROBE (with larger relation S)                       â”‚
    â”‚            For each S tuple, hash and check bucket for matches  â”‚
    â”‚                                                                  â”‚
    â”‚                                                                  â”‚
    â”‚            BUILD PHASE              PROBE PHASE                 â”‚
    â”‚                                                                  â”‚
    â”‚   R tuples                    S tuples                          â”‚
    â”‚     â”‚                           â”‚                               â”‚
    â”‚     â†“ hash(A)                   â†“ hash(B)                       â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
    â”‚   â”‚Bucket 0 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Check 0 â”‚                         â”‚
    â”‚   â”‚Bucket 1 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Check 1 â”‚                         â”‚
    â”‚   â”‚Bucket 2 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Check 2 â”‚                         â”‚
    â”‚   â”‚  ...    â”‚               â”‚  ...    â”‚                         â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
    â”‚                                                                  â”‚
    â”‚   Cost: 3(bR + bS) if enough memory                            â”‚
    â”‚   Best for: equality joins, one relation fits in memory        â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    JOIN ALGORITHM COMPARISON:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     Algorithm      â”‚    Best    â”‚   Worst    â”‚    When to Use   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Nested Loop        â”‚ Small R    â”‚ Large RÃ—S  â”‚ Small datasets   â”‚
    â”‚ Block Nested Loop  â”‚ Memory fit â”‚ Many blocksâ”‚ Limited memory   â”‚
    â”‚ Sort-Merge         â”‚ Pre-sorted â”‚ Sort cost  â”‚ Already sorted   â”‚
    â”‚ Hash Join          â”‚ Memory fit â”‚ Hash build â”‚ Equality joins   â”‚
    â”‚ Index Nested Loop  â”‚ Index      â”‚ Many loops â”‚ Indexed inner    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Cost Estimation Basics

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COST ESTIMATION                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    The optimizer needs to ESTIMATE cost before execution.
    Cost is measured in disk I/O (block reads/writes).
    

    STATISTICS MAINTAINED:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   For each table R:                                             â”‚
    â”‚   â€¢ nR = number of tuples                                       â”‚
    â”‚   â€¢ bR = number of blocks                                       â”‚
    â”‚   â€¢ lR = tuple size (bytes)                                     â”‚
    â”‚   â€¢ fR = blocking factor (tuples per block)                     â”‚
    â”‚                                                                  â”‚
    â”‚   For each attribute A:                                         â”‚
    â”‚   â€¢ V(A,R) = number of distinct values                          â”‚
    â”‚   â€¢ min(A,R) = minimum value                                    â”‚
    â”‚   â€¢ max(A,R) = maximum value                                    â”‚
    â”‚                                                                  â”‚
    â”‚   For each index:                                               â”‚
    â”‚   â€¢ Height of B+-tree                                           â”‚
    â”‚   â€¢ Number of leaf pages                                        â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    SELECTIVITY ESTIMATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Selectivity = fraction of tuples that satisfy condition
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   Condition: A = value                                          â”‚
    â”‚   Selectivity = 1 / V(A,R)                                      â”‚
    â”‚   (assume uniform distribution)                                 â”‚
    â”‚                                                                  â”‚
    â”‚   Example: 1000 employees, 50 departments                       â”‚
    â”‚   Ïƒ(dept = 'IT') selectivity = 1/50 = 0.02                     â”‚
    â”‚   Expected result: 1000 Ã— 0.02 = 20 tuples                     â”‚
    â”‚                                                                  â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                                                                  â”‚
    â”‚   Condition: A > value (range)                                  â”‚
    â”‚   Selectivity = (max - value) / (max - min)                    â”‚
    â”‚                                                                  â”‚
    â”‚   Example: salary between 0 and 100000                         â”‚
    â”‚   Ïƒ(salary > 60000) selectivity = (100000-60000)/(100000-0)    â”‚
    â”‚                                 = 0.4                           â”‚
    â”‚                                                                  â”‚
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                                                                  â”‚
    â”‚   Conjunctions: A AND B                                         â”‚
    â”‚   Selectivity â‰ˆ sel(A) Ã— sel(B)  (assume independence)         â”‚
    â”‚                                                                  â”‚
    â”‚   Disjunctions: A OR B                                          â”‚
    â”‚   Selectivity â‰ˆ sel(A) + sel(B) - sel(A)Ã—sel(B)                â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    JOIN SIZE ESTIMATION:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                  â”‚
    â”‚   R â‹ˆ S on R.A = S.B                                           â”‚
    â”‚                                                                  â”‚
    â”‚   If A is key of R and B is foreign key referencing R:         â”‚
    â”‚   Result size = nS (each S tuple matches exactly one R tuple)  â”‚
    â”‚                                                                  â”‚
    â”‚   General case:                                                  â”‚
    â”‚   Result size â‰ˆ (nR Ã— nS) / max(V(A,R), V(B,S))               â”‚
    â”‚                                                                  â”‚
    â”‚   Example:                                                       â”‚
    â”‚   â€¢ Employees (1000 rows) join Departments (50 rows)           â”‚
    â”‚   â€¢ On emp.dept_id = dept.id                                   â”‚
    â”‚   â€¢ V(dept_id, emp) = 50, V(id, dept) = 50                     â”‚
    â”‚   â€¢ Size â‰ˆ (1000 Ã— 50) / 50 = 1000 (each emp matches one dept) â”‚
    â”‚                                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COST FORMULAS:
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        Operation                   â”‚         Cost               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Full table scan                    â”‚ bR                         â”‚
    â”‚ Primary index equality             â”‚ height + 1                 â”‚
    â”‚ Secondary index equality           â”‚ height + 1 + matches       â”‚
    â”‚ Nested loop join                   â”‚ bR + (bR Ã— bS)            â”‚
    â”‚ Sort-merge join                    â”‚ Sort(R) + Sort(S) + bR+bS â”‚
    â”‚ Hash join                          â”‚ 3(bR + bS)                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Summary Table

| Processing Phase | Input | Output |
|------------------|-------|--------|
| **Parsing** | SQL text | Parse tree |
| **Validation** | Parse tree | Verified parse tree |
| **Translation** | Parse tree | Query tree (algebra) |
| **Optimization** | Query tree | Execution plan |
| **Execution** | Execution plan | Query results |

| Selection Method | Cost | Requirements |
|------------------|------|--------------|
| **Linear scan** | b blocks | None |
| **Binary search** | logâ‚‚(b) | Sorted file |
| **Primary index** | height + 1 | B+-tree on key |
| **Secondary index** | height + matches | B+-tree on attr |

| Join Algorithm | Cost | Best When |
|----------------|------|-----------|
| **Nested Loop** | bR Ã— bS | Small tables |
| **Sort-Merge** | Sort + bR + bS | Already sorted |
| **Hash Join** | 3(bR + bS) | Fits in memory |

---

## â“ Quick Revision Questions

1. **What is the role of the system catalog in query validation?**
   <details>
   <summary>Click for Answer</summary>
   The system catalog stores metadata: table names, column names and types, constraints, indexes, and permissions. During validation, the DBMS queries the catalog to verify that referenced tables and columns exist, types are compatible, and the user has appropriate privileges.
   </details>

2. **Why is the canonical (initial) query tree often inefficient?**
   <details>
   <summary>Click for Answer</summary>
   The canonical tree directly translates SQL without optimization. It typically puts selections and projections AFTER joins, and may use Cartesian products. For example, computing R Ã— S before filtering wastes resources creating many tuples that will be discarded. Optimization restructures this.
   </details>

3. **When is a secondary index scan worse than a full table scan?**
   <details>
   <summary>Click for Answer</summary>
   When the selection matches many rows (low selectivity). Each matching record requires a random disk access. If 40% of rows match, secondary index does 40% Ã— n random I/Os, while full scan does b sequential I/Os. Sequential is much faster, so full scan wins for low selectivity.
   </details>

4. **What is the difference between nested loop join and block nested loop join?**
   <details>
   <summary>Click for Answer</summary>
   Nested loop compares each tuple of R with each tuple of S, causing many disk reads. Block nested loop reads blocks of R into memory, then scans S once per R-block (not per R-tuple). Cost drops from bR + nRÃ—bS to bR + bRÃ—bS, a huge improvement.
   </details>

5. **How does hash join work and when is it most effective?**
   <details>
   <summary>Click for Answer</summary>
   Build phase: hash the smaller relation into memory buckets on join key. Probe phase: for each tuple in the larger relation, hash its key and check the matching bucket for joins. Most effective for equality joins when the smaller relation fits in memory. Cost is about 3(bR + bS).
   </details>

6. **What statistics does the optimizer use to estimate selectivity?**
   <details>
   <summary>Click for Answer</summary>
   Key statistics: (1) Number of tuples nR, (2) Number of distinct values V(A,R) for each attribute, (3) Min and max values for range estimates. Selectivity for A=v is 1/V(A,R); for A>v is (max-v)/(max-min). These assume uniform distribution - histograms provide better estimates.
   </details>

---

## ğŸ”— Navigation

| Previous | Up | Next |
|----------|----|----|
| [â† Hashing Techniques](../06-File-Organization/04-hashing-techniques.md) | [ğŸ“š Table of Contents](../README.md) | [Query Optimization â†’](02-query-optimization.md) |

---

*Last Updated: January 2026*
