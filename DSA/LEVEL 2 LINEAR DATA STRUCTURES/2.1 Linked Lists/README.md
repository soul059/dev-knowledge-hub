# ðŸ”— Linked Lists â€” Complete Study Guide

> **Level 2: Linear Data Structures â€” Module 2.1**

---

## Course Overview

This module provides a **comprehensive deep-dive into Linked Lists** â€” one of the most fundamental and versatile data structures in computer science. Starting from the basics of singly linked lists, we progressively build up to advanced techniques like fast-and-slow pointers, merge operations, and memory management concepts.

Each unit is designed for **concept mastery, logic building, and problem-solving fluency**. You will find:

- Clear conceptual explanations with **ASCII diagrams**
- **Pseudocode** with step-by-step traces
- **Time & Space complexity** analysis for every operation
- Common **patterns and techniques** used in interviews and competitive programming
- **Practice problem types** and strategies
- **Summary tables** and **quick revision questions** per chapter

---

## How to Use These Notes

1. **Read sequentially** â€” units build on each other
2. **Trace the diagrams** by hand on paper
3. **Implement the pseudocode** in your preferred language
4. **Attempt revision questions** before moving to the next chapter
5. **Revisit summary tables** for quick revision before interviews

---

## Complete Table of Contents

### [Unit 1: Singly Linked List Basics](01-Singly-Linked-List-Basics/)

| # | Chapter | File |
|---|---------|------|
| 1 | What is a Linked List? / Node Structure | [01-what-is-a-linked-list.md](01-Singly-Linked-List-Basics/01-what-is-a-linked-list.md) |
| 2 | Head, Tail, and Traversal | [02-head-tail-and-traversal.md](01-Singly-Linked-List-Basics/02-head-tail-and-traversal.md) |
| 3 | Array vs Linked List / When to Use | [03-array-vs-linked-list.md](01-Singly-Linked-List-Basics/03-array-vs-linked-list.md) |

---

### [Unit 2: Singly Linked List Operations](02-Singly-Linked-List-Operations/)

| # | Chapter | File |
|---|---------|------|
| 1 | Insertion Operations | [01-insertion-operations.md](02-Singly-Linked-List-Operations/01-insertion-operations.md) |
| 2 | Deletion and Search Operations | [02-deletion-and-search.md](02-Singly-Linked-List-Operations/02-deletion-and-search.md) |
| 3 | Edge Cases and Complexity Analysis | [03-edge-cases-and-complexity.md](02-Singly-Linked-List-Operations/03-edge-cases-and-complexity.md) |

---

### [Unit 3: Doubly Linked List](03-Doubly-Linked-List/)

| # | Chapter | File |
|---|---------|------|
| 1 | DLL Structure and Advantages | [01-dll-structure-and-advantages.md](03-Doubly-Linked-List/01-dll-structure-and-advantages.md) |
| 2 | DLL Insertion and Deletion | [02-dll-insertion-and-deletion.md](03-Doubly-Linked-List/02-dll-insertion-and-deletion.md) |
| 3 | DLL Traversal and Trade-offs | [03-dll-traversal-and-tradeoffs.md](03-Doubly-Linked-List/03-dll-traversal-and-tradeoffs.md) |

---

### [Unit 4: Circular Linked List](04-Circular-Linked-List/)

| # | Chapter | File |
|---|---------|------|
| 1 | Singly and Doubly Circular Lists | [01-circular-list-types.md](04-Circular-Linked-List/01-circular-list-types.md) |
| 2 | Operations on Circular Lists | [02-circular-list-operations.md](04-Circular-Linked-List/02-circular-list-operations.md) |
| 3 | Use Cases & Classic Problems | [03-use-cases-and-problems.md](04-Circular-Linked-List/03-use-cases-and-problems.md) |

---

### [Unit 5: Fast and Slow Pointers](05-Fast-And-Slow-Pointers/)

| # | Chapter | File |
|---|---------|------|
| 1 | Concept and Cycle Detection | [01-concept-and-cycle-detection.md](05-Fast-And-Slow-Pointers/01-concept-and-cycle-detection.md) |
| 2 | Cycle Length and Start Point | [02-cycle-length-and-start.md](05-Fast-And-Slow-Pointers/02-cycle-length-and-start.md) |
| 3 | Middle Node and Nth from End | [03-middle-node-and-nth-from-end.md](05-Fast-And-Slow-Pointers/03-middle-node-and-nth-from-end.md) |

---

### [Unit 6: Linked List Reversal](06-Linked-List-Reversal/)

| # | Chapter | File |
|---|---------|------|
| 1 | Iterative and Recursive Reversal | [01-iterative-and-recursive-reversal.md](06-Linked-List-Reversal/01-iterative-and-recursive-reversal.md) |
| 2 | Reverse in Groups and Between Positions | [02-reverse-in-groups.md](06-Linked-List-Reversal/02-reverse-in-groups.md) |
| 3 | Palindrome Check and DLL Reversal | [03-palindrome-and-dll-reversal.md](06-Linked-List-Reversal/03-palindrome-and-dll-reversal.md) |

---

### [Unit 7: Merge Operations](07-Merge-Operations/)

| # | Chapter | File |
|---|---------|------|
| 1 | Merge Two Sorted Lists | [01-merge-two-sorted-lists.md](07-Merge-Operations/01-merge-two-sorted-lists.md) |
| 2 | Merge K Sorted Lists and Merge Sort | [02-merge-k-and-merge-sort.md](07-Merge-Operations/02-merge-k-and-merge-sort.md) |
| 3 | Intersection and Union | [03-intersection-and-union.md](07-Merge-Operations/03-intersection-and-union.md) |

---

### [Unit 8: Advanced Problems](08-Advanced-Problems/)

| # | Chapter | File |
|---|---------|------|
| 1 | Flatten and Clone Operations | [01-flatten-and-clone.md](08-Advanced-Problems/01-flatten-and-clone.md) |
| 2 | Arithmetic and Reordering | [02-arithmetic-and-reordering.md](08-Advanced-Problems/02-arithmetic-and-reordering.md) |
| 3 | Rotation and Sorting | [03-rotation-and-sorting.md](08-Advanced-Problems/03-rotation-and-sorting.md) |

---

### [Unit 9: Memory Management](09-Memory-Management/)

| # | Chapter | File |
|---|---------|------|
| 1 | Memory Allocation and Leaks | [01-memory-allocation-and-leaks.md](09-Memory-Management/01-memory-allocation-and-leaks.md) |
| 2 | Garbage Collection and Smart Pointers | [02-garbage-collection-and-smart-pointers.md](09-Memory-Management/02-garbage-collection-and-smart-pointers.md) |
| 3 | Cache Performance and XOR Linked List | [03-cache-performance-and-xor-list.md](09-Memory-Management/03-cache-performance-and-xor-list.md) |

---

## Quick Reference â€” Core Complexities

| Operation | Singly LL | Doubly LL | Array |
|-----------|-----------|-----------|-------|
| Access by index | O(n) | O(n) | O(1) |
| Insert at head | O(1) | O(1) | O(n) |
| Insert at tail | O(n)* | O(1)** | O(1)*** |
| Insert at middle | O(n) | O(n) | O(n) |
| Delete at head | O(1) | O(1) | O(n) |
| Delete at tail | O(n) | O(1)** | O(1) |
| Search | O(n) | O(n) | O(n) |

\* O(1) if tail pointer maintained &nbsp;&nbsp; \** With tail pointer &nbsp;&nbsp; \*** Amortized

---

## Prerequisites

- Understanding of basic data types and variables
- Familiarity with pointers / references
- Basic knowledge of arrays
- Comfort with recursion (helpful for later units)

---

## Legend

| Symbol | Meaning |
|--------|---------|
| `-->` | Pointer / link between nodes |
| `[data\|next]` | Node with data and next pointer |
| `NULL` | End of list / no reference |
| `HEAD` | First node pointer |
| `TAIL` | Last node pointer |

---

*Happy Learning! Start with [Unit 1 â†’](01-Singly-Linked-List-Basics/01-what-is-a-linked-list.md)*
